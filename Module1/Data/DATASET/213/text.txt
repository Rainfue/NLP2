С момента появления Node.js вызывал растущий интерес в среде разработчиков.
Сильные стороны Node.js – это возможность обращения к серверной части и огромным
объемам данных удобным и эффективным способом, а также одновременная обработка
огромного количества соединений с большой пропускной способностью. Это инициировало
многочисленные разработки различных фреймворков для создания более эффективных
инструментов на основе данной технологии [1–4].
На сегодняшний день сформировался широкий выбор фреймворков, самые
примечательные из которых – это Express и Koa, созданные организацией Node.js Foundation.
Express.js в первую очередь использует первичные принципы и подходы Node.js,
расширяя функциональные возможности в значительной степени и создавая новые
удобные функции. Данный фреймворк является минималистичным и очень надежным
инструментом для создания одностраничных и многостраничных сайтов, а также
интерфейсов прикладного уровня (API), в то же время он гарантирует максимальную
возможную производительность.
Koa.js предоставляет мощный каркас сервера для создания эффективных вебприложений и интерфейсов прикладного уровня (API). Фреймворк был написан
полностью с нуля, во многом он похож на Express, но есть одно существенное отличие –больше не используются функции обратного вызова (callback). Он не обременен
поддержкой legacy-кода, поэтому код был переписан на современный ES6 (ES2015).
Вместо функций обратного вызова в первой версии используются так называемые
корутины – это функции библиотеки Co, использующие генераторы и обещания
(Promise). Но разработчики не стали останавливаться на этом и выпустили вторую
версию фреймворка, написанного на стандарте ES2016 и ES2017.
Создание фреймворка Koa.js на экспериментальной на данный момент
спецификации было необходимо для предоставления возможности написания более
понятного, производительного и минималистичного кода разработчиками. Это было
достигнуто благодаря избавлению от бесконечно вложенных функций обратного
вызова.
Одной из сильнейших сторон JavaScript является работа с асинхронным кодом.
Для решения асинхронных задач используется обработка событий, что является
универсальным подходом или с помощью менее удобного способа – функций обратного
вызова (callback).
Самый существенный недостаток функций обратного вызова с точки зрения
организации кода, это образование: «callback hell» или «pyramide of doom». Проблема
состоит в том, что в параметрах вызываемой функции есть параметр, который является
также функцией обратного вызова – и все это может продолжаться до бесконечности. Оба состояния возвращают обещания, что позволяет выстраивать цепочки запросов с
обработкой данных.
Следующим инструментом являются функции – генераторы (Generator). Данный
инструмент предоставляет очень мощный механизм написания чистого и понятного
асинхронного кода. В основе работы генератора лежит использование стекового кадра,
позволяющего выполнять передачи аргументов и выделение временной памяти с
использованием системного стека. Во время выполнения генератора нет никакой
параллельности, действия происходят синхронно и однопоточно. Используя генераторы,
необходимо писать функции для последовательного перебора next() методов или циклы. Есть
уже готовые библиотеки с готовыми реализациями переборов, а также обладающих большим
количеством возможностей.
Одна из самых известных библиотек – это Co. Библиотека объединяет различные
функции-обертки (корутины) над обещаниями и генераторами, позволяющие писать простой
и понятный псевдосинхронный код.
Корутина (coroutine) – это функция, построенная на основе генераторов, позволяющая
контролировать и многократно передавать как вовне так и внутрь функции данные. Каждая
созданная корутина является специальной «функцией-чернорабочим» которая запускает
генератор и последовательными вызовами next() получает из него промисы.
Новый инструмент async/await работающий на обещаниях и генераторах, избавляет от
необходимости использования then() методов обещаний. Алгоритм работы построен на
переборе последовательности генератора (из await выражений), упаковывающего каждый
элемент последовательности в свое обещание, после чего формируются цепочки. Благодаря
такому удобному «синтаксическому сахару» над генераторами и обещаниями, писать
асинхронные функции через async/await гораздо удобнее: получается меньше кода и
пропадает необходимость в оборачивании промисов в генераторы.
После принятия ECMAScript 6.0 было исправлено много ошибок, добавлены классы,
стрелочные функции, увеличена производительность, но самое главное нововведение – это
обещания и генераторы – инструменты для работы с асинхронными функциями и запросами.
На рис. 3 представлено сравнение затраченного времени на работу новых инструментов и
функций обратного вызова.
