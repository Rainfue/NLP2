В современном мире, где технологии развиваются с каждым днем,
вопросы производительности программного обеспечения стоят особенно
остро. Java, будучи одним из самых популярных языков программирования в
мире, используется в широком спектре приложений - от веб-сервисов и
корпоративных решений до мобильных приложений и систем больших
данных. Оптимизация производительности этих приложений не только
улучшает пользовательский опыт, но и снижает операционные затраты, что
делает тему актуальной как для разработчиков, так и для бизнеса.
С учетом постоянно увеличивающегося объема данных и требований к
быстродействию, понимание тонкостей и нюансов Java является ключевым
элементом для создания эффективных и надежных приложений. К тому же, с
появлением новых версий Java и обновлений JVM, возникают новые
возможности для оптимизации, а также новые вызовы.
Также, обсуждение распространенных ошибок и лучших практик в
контексте производительности помогает предотвратить потенциальные
проблемы на ранней стадии разработки, сокращая время и ресурсы,
необходимые для отладки и рефакторинга. Таким образом, статья не только
повышает осведомленность о важности оптимизации производительности, но
и предоставляет практические инструменты для ее достижения.
XXIII Международная научно-практическая конференция
«Вызовы современности и стратегии развития общества в условиях новой реальности»
281
Для эффективного управления памятью и оптимизации
производительности необходимо понимать, как работает сборка мусора,
каким образом мы можем настраивать память приложения и какой необходим
баланс для достижения максимальной работоспособности приложения
Управление памятью является критическим аспектом в Java, где
ключевую роль играет сборщик мусора (GC). GC автоматически освобождает
память, занятую объектами, которые больше не используются. Эффективность
GC напрямую влияет на производительность приложения, поскольку
неправильно настроенный GC может привести к частым и продолжительным
паузам в работе приложения. Понимание различных типов сборщиков мусора
в JVM, таких как Serial, Parallel, G1 и ZGC, и их подходящих сценариев
использования помогает в оптимизации производительности Javaприложений.
Сборщик мусора (GC) в Java автоматически управляет памятью, выделяя
и освобождая память для объектов. Ключевой задачей GC является
идентификация и удаление объектов, которые больше не используются
приложением, то есть объектов, на которые не существует активных ссылок.
У GC выделяют 2 фазы работы - от Отметка (Marking) и Удаление (Sweeping).
Отметка (Marking): GC сканирует память, начиная с "корневых" объектов
(например, локальных переменных и активных потоков), и отмечает все
достижимые объекты. Удаление (Sweeping): Объекты, не отмеченные как
достижимые, считаются "мусором" и удаляются, освобождая память.
Java-память разделена на несколько "поколений", что помогает
оптимизировать работу GC:
1. Молодое поколение (Young Generation): Здесь создаются новые
объекты. Молодое поколение далее делится на три части - Eden Space и
два Survivor Space. Большинство объектов умирают здесь, и когда это
поколение заполняется, происходит "минорная" сборка мусора.
2. Старое поколение (Old Generation): Объекты, которые пережили
несколько минорных сборок мусора, перемещаются сюда. Когда старое
поколение заполняется, происходит "мажорная" сборка мусора, которая
обычно занимает больше времени.
3. Постоянное поколение (Permanent Generation)/Метаспейс (MetaSpace):
Здесь хранится метадата классов и статические поля. В современных
версиях Java (начиная с Java 8), это поколение заменено на MetaSpace,
который использует нативную память.
При работе с настройкой GC необходимо знать следующие основные
принципы. Остановка всего мира (Stop-the-World Events): Во время сборки
мусора, выполнение приложения может быть приостановлено, что может
влиять на производительность. Неправильно настроенный GC может привести
к частым или продолжительным паузам, снижая производительность
XXIII Международная научно-практическая конференция
«Вызовы современности и стратегии развития общества в условиях новой реальности»
282
приложения. Регулярный мониторинг и настройка параметров GC могут
помочь оптимизировать работу приложения.
Теперь мы можем разобрать работу приложения Visual GC. Данное
приложение бесплатное, с открытым кодом. При запуске Java-приложения и
Visual GC, последнее автоматически находит первое и начинает мониторинг
его состояния.
Рисунок 10 - скриншот приложения Visual GC
На изображении представлен скриншот утилиты мониторинга сборщика
мусора для Java Virtual Machine (JVM), которая часто называется Visual GC.
Эта утилита отображает различные области памяти внутри JVM и активность
сборщика мусора в реальном времени. Вот основные элементы, которые
можно увидеть на картинке:
Spaces: В верхней части интерфейса перечислены различные "пространства"
или области памяти внутри кучи JVM:
Perm: Постоянное поколение, где хранится метадата классов и статические
ресурсы.
Old: Старое поколение, для объектов, которые существуют дольше и пережили
несколько циклов сборки мусора.
Eden: Область, где создаются все новые объекты.
S0 и S1: Survivor spaces, области, куда перемещаются объекты из Eden после
первой сборки мусора.
XXIII Международная научно-практическая конференция
«Вызовы современности и стратегии развития общества в условиях новой реальности»
283
Graphs: На графиках отображается активность сборщика мусора и
использование различных областей памяти.
Compile Time: Время, затраченное на компиляцию методов JIT-компилятором.
Class Loader: Статистика загрузки и выгрузки классов.
GC Time и GC Causes: Общее время, затраченное на сборку мусора, и причины,
по которым она инициировалась.
Запуск был произведен при настройках указанных на рисунке 2.
Рисунок 11 – обычная конфигурация окружения
JAVA_OPTS: Эта переменная окружения часто используется для
определения параметров командной строки, которые будут переданы в JVM
при запуске Java-приложения. Значение этой переменной содержит
следующие настройки:
-Xms1400m: Устанавливает начальный размер кучи JVM в 1400
мегабайт.
-Xmx1400m: Задаёт максимальный размер кучи JVM в 1400 мегабайт.
-Xmn525m: Устанавливает размер молодого поколения (young
generation) в 525 мегабайт.
-XX:PermSize=20m: Задаёт начальный размер области памяти PermGen
(устаревшее в Java 8 и выше) в 20 мегабайт.
-XX:MaxPermSize=20m: Устанавливает максимальный размер области
памяти PermGen в 20 мегабайт.
MAIN_CLASS: Эта переменная окружения обычно используется для
указания основного класса Java-приложения, который будет запущен JVM. В
данном случае, основной класс указан как ru.skuptsov.MemoryConsumer.
Всего за 30 сек эксперимента было произведено 54 сборки — 31 малых
и 23 полных — с общим временем остановки 3,227c. Данная величина
задержки может не удовлетворять необходимым требованиям — посмотрим,
сможем ли мы улучшить ситуацию без изменения кода приложения.
Если время задержки нас не устраивает — можно перейти к concurrent
garbage collector, включив опцию -XX:+UseConcMarkSweepGC — алгоритм,
XXIII Международная научно-практическая конференция
«Вызовы современности и стратегии развития общества в условиях новой реальности»
284
который будет пытаться выполнять основную работу по маркировке объектов
на удаление в отдельном потоке параллельно потокам приложения.
ConcMarkSweep GC требует более внимательной настройки, — одной из
основных целей является уменьшение количества stop-the-world пауз при
отсутствии достаточного места в old generation для расположения объектов —
т.к. эта фаза занимает в среднем больше времени, чем фаза полной сборки
мусора при throughput GC. Как результат — может увеличиться длительность
худшего случая сборки мусора, необходимо избегать частых переполнений old
generation. Как правило, — при переходе на ConcMarkSweep GC рекомендуют
увеличить размер old generation на 20-30% — запустим jvm с параметрами:
Рисунок 12 – конфигурация приложения с алгоритмом ConcMarkSweep
С учетом данных настроек мы смогли получить результат, показанный
на рисунке 4. Как можно видеть удалось сократить общее временя остановки
с 3,227c до 1,923 с. Если даже такой результат считается
неудовлетворительным имеет смысл попробовать расширить приложение
горизонтально или использовать более современные виды GC, а также
попытаться менять настройки других областей памяти. Например, можно
корректировать размер survivor, eden и так далее. Однако, необходимо
помнить, что чем больше становится размер кучи в Java приложении, тем
больший объем памяти приходится обходить GC, следовательно
увеличивается время на обход приложения, а это увеличивает stop-the-world
паузы. Во время сборки мусора, выполнение приложения может быть
приостановлено, что может влиять на производительность. Важно найти
баланс между объемами отдельных участков памяти JVM.
XXIII Международная научно-практическая конференция
«Вызовы современности и стратегии развития общества в условиях новой реальности»
285
Рисунок 13 - скриншот приложения Visual GC с учетом примененных
опптимизаций
Этот инструмент используется для визуализации и оптимизации работы
сборщика мусора, позволяя разработчикам и системным администраторам
наблюдать за работой приложения и производить необходимые настройки в
реальном времени для улучшения производительности.
В заключение можно сказать, что настройки виртуальной машины Java
(JVM) играют важную роль в оптимизации производительности приложений.
Параметры, такие как размер кучи, выбор и настройка сборщика мусора, и
другие JVM флаги, могут существенно повлиять на производительность.
Например, недостаточный размер кучи может привести к частым сборкам
мусора, в то время как излишне большой размер может увеличить
продолжительность каждой сборки. Также, настройки, связанные с JITкомпиляцией (Just-In-Time), помогают улучшить производительность за счет
оптимизации исполняемого кода во время выполнения. Понимание и
правильная настройка этих параметров могут значительно улучшить
производительность Java-приложений. Учитывая постоянно растущие
требования к программному обеспечению и огромное влияние
производительности на успех технологических продуктов и услуг, эта статья
представляет собой неотъемлемый ресурс для любого профессионала в
области Java-разработки.