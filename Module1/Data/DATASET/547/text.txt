Различные языки и их среда выполнения часто оптимизированы для определенного набора сценариев использования, и React не является исключением.
Программы React обычно выводят дерево, которое со временем может меняться. Это может
быть дерево DOM, иерархия iOS, дерево примитивов PDF или даже объектов JSON. Однако обычно
необходимо представить им какой-то пользовательский интерфейс. Мы будем называть его «деревом
хостов», потому что это часть среды хоста за пределами React, например DOM или iOS. Дерево хостов
обычно имеет собственный императивный API. React - это слой поверх него.
Аннотация. Большинство руководств представляют JavaScript-библиотеку React как библиотеку пользовательского интерфейса. Это имеет смысл, потому что React - это UI-библиотека. В данной статье
React рассматривается по-другому - как среда (система) выполнения кода, с помощью которой создаются пользовательские интерфейсы. В статье анализируются продвинутые подходы разработки на
React, модели программирования, а также работа библиотеки изнутри.
Ключевые слова: es5, es6, javascript, reactjs, hooks, dom.
ANALYZING THE WORK OF THE REACT LIBRARY FROM THE INSIDE, AS WELL AS APPLYING
ADVANCED APPROACHES IN THE DEVELOPMENT OF MODERN WEB INTERFACES
Kniazev Ilia,
Kopteva Anna
Abstract. Most tutorials present the React JavaScript library as a user interface library. This makes sense because React is a UI library. This article takes React differently - as a code execution environment (system) with
which to create user interfaces. The article analyzes advanced development approaches in React, programming models, as well as the work of the library from the inside.
Key words: es5, es6, javascript, reactjs, hooks, dom.
78 СОВРЕМЕННЫЕ ТЕХНОЛОГИИ
международная научно-практическая конференция | МЦНС «НАУКА И ПРОСВЕЩЕНИЕ»
Очень абстрактно React помогает написать программу, которая предсказуемо манипулирует
сложным деревом хостов в ответ на внешние события, такие как взаимодействия, сетевые ответы,
таймеры и т. Д.
Специализированный инструмент работает лучше, чем общий, когда он может налагать определенные ограничения и извлекать из них пользу. React делает ставку на два принципа:
 Стабильность. Дерево хостов относительно стабильно, и большинство обновлений не меняют
радикально его общую структуру. Если бы приложение каждую секунду переставляло все свои интерактивные элементы в совершенно другую комбинацию, им было бы сложно пользоваться.
 Регулярность. Дерево хостов можно разбить на шаблоны пользовательского интерфейса, которые выглядят и ведут себя согласованно (например, кнопки, списки, аватары), а не на случайные формы.
Эти принципы верны для большинства пользовательских интерфейсов. Однако React не подходит, когда на выходе нет стабильных «шаблонов».
Хост-инстансы
Дерево хостов состоит из узлов. Мы будем называть их «хост-экземплярами».
В среде DOM экземпляры хоста являются обычными узлами DOM - как объекты, которые вы получаете, когда вызываете document.createElement ('div'). В iOS экземпляры хоста могут быть значениями, однозначно идентифицирующими собственное представление из JavaScript.
У экземпляров хоста есть свои собственные свойства (например, domNode.className или
view.tintColor). Они также могут содержать другие экземпляры хоста в качестве дочерних.
Обычно существует API для управления экземплярами хоста. Например, DOM предоставляет такие API, как appendChild, removeChild, setAttribute и т. Д. В приложениях React вы обычно не вызываете
эти API, т.к это работа на стороне React.
Рендереры
Средство визуализации учит React взаимодействовать с конкретной средой хоста и управлять ее
экземплярами хоста. React DOM, React Native и даже Ink являются рендерерами React. Вы также можете создать свой собственный рендерер React.
Рендереры React могут работать в одном из двух режимов.
Подавляющее большинство средств визуализации написано для использования режима «мутации». В этом режиме работает DOM: мы можем создать узел, установить его свойства, а затем добавить или удалить из него дочерние элементы. Экземпляры хоста полностью изменяемы.
React также может работать в «постоянном» режиме. Этот режим предназначен для сред хоста,
которые не предоставляют такие методы, как appendChild(), а вместо этого клонируют родительское
дерево и всегда заменяют дочерний элемент верхнего уровня. Неизменяемость на уровне дерева хостов упрощает многопоточность. React Fabric использует это в своих интересах.
React Elements
В среде хоста экземпляр хоста (например, узел DOM) является наименьшим строительным блоком. В React самым маленьким строительным блоком является элемент React.
Элемент React - это простой объект JavaScript. Он может описывать хост-экземпляр.
// <article className = "test" />
{
 type: article,
 props: { className: test }
}
Элемент React легкий и не имеет привязанного к нему экземпляра хоста. Опять же, это просто
описание того, что вы хотите видеть на экране.
Как и хост-экземпляры, элементы React могут образовывать дерево:
СОВРЕМЕННЫЕ ТЕХНОЛОГИИ 79
International scientific conference | www.naukaip.ru
Рис. 1. Дерево элементов React
Однако помните, что элементы React не имеют собственной постоянной идентичности. Их нужно
постоянно создавать заново и выбрасывать.
Элементы React неизменны. Например, вы не можете изменить дочерние элементы или свойство элемента React. Если позже отрендерить что-то другое, необходимо будет описать это с помощью
нового дерева элементов React, созданного с нуля.
Входная точка
У каждого модуля рендеринга React есть «точка входа». Это API, который позволяет нам указать
React отрисовать конкретное дерево элементов React внутри экземпляра узла контейнера.
Например, точка входа React DOM - ReactDOM.render:
ReactDOM.render (
 // {type: div, props: {className: test}}
 <div className = "blue" />,
 document.getElementById ('container’)
);
React посмотрит на responseElement.type (div) и попросит средство визуализации React DOM создать для него экземпляр хоста и установить свойства:
Рис. 2. Функция createHostInstance
80 СОВРЕМЕННЫЕ ТЕХНОЛОГИИ
международная научно-практическая конференция | МЦНС «НАУКА И ПРОСВЕЩЕНИЕ»
В нашем примере React действительно сделает это:
let domNode = document.createElement (‘div’);
domNode.className = test;
domContainer.appendChild (domNode);
Если у элемента React есть дочерние элементы в reactElement.props.children, React рекурсивно
создаст для них экземпляры хоста при первом рендеринге.
Задача React - привести дерево хостов в соответствие с предоставленным деревом элементов
React. Процесс определения того, что делать с деревом экземпляров хоста в ответ на новую информацию, иногда называют согласованием.
Есть два способа сделать это. Упрощенная версия React может уничтожить существующее дерево и воссоздать его с нуля:
let domContainer = document.getElementById ('container');
// Очищаем дерево
domContainer.innerHTML = '';
// Создаем новое дерево экземпляра хоста
let domNode = document.createElement ('div’);
domNode.className = 'test';
domContainer.appendChild (domNode);
Но в DOM это происходит медленно и теряется такая важная информация, как фокус, выбор, состояние прокрутки и т. Д. Вместо этого мы хотим, чтобы React делал что-то вроде этого:
let domNode = domContainer.firstChild;
// Обновляем существующий экземпляр хоста
domNode.className = 'test';
Рис. 3. Пример использования экземпляра хоста
СОВРЕМЕННЫЕ ТЕХНОЛОГИИ 81
International scientific conference | www.naukaip.ru
Другими словами, React должен решить, когда обновить существующий экземпляр хоста, чтобы
он соответствовал новому элементу React, а когда создать новый.
Это поднимает вопрос идентичности. Элемент React может каждый раз отличаться, но когда он
концептуально относится к одному и тому же экземпляру хоста?
В нашем примере это просто. Мы использовали для рендеринга <div> как первого (и единственного) потомка, и мы хотим снова рендерить <div> в том же месте. Это довольно похоже на то, как React
думает об этом.
Если тип элемента в одном и том же месте дерева «совпадает» между предыдущим и следующим рендерингом, React повторно использует существующий экземпляр хоста.
Пример с комментариями, примерно показывающий, что делает React представлен на рис. 3.
Та же логика используется для дочерних деревьев. Например, когда мы обновляем <section>
двумя <button> внутри, React сначала решает, следует ли повторно использовать <section>, а затем
повторяет эту процедуру принятия решения для каждого дочернего элемента.
Условия
Если React повторно использует экземпляры хоста только тогда, когда типы элементов «совпадают» между обновлениями, как мы можем отображать условный контент?
Скажем, мы хотим сначала показать только ввод, но позже отобразить сообщение перед ним:
Рис. 4. Рендер ReactDOM
В этом примере экземпляр хоста <input> будет воссоздан заново. React будет обходить дерево
элементов, сравнивая его с предыдущей версией используя следующую логику:
article → article: Можно повторно использовать хост-экземпляр? Да - тип совпадает.
input → p: Можно повторно использовать экземпляр хоста? Нет, поменяли тип!
Необходимо удалить существующий ввод и создать новый экземпляр хоста p.
(undefined) → ввод: необходимо создать новый экземпляр узла ввода.
Таким образом, код обновления, выполняемый React, будет выглядеть так:
let oldInputNode = dialogNode.firstChild;
dialogNode.removeChild (oldInputNode);
let pNode = document.createElement ('p');
pNode.textContent = 'Text';
82 СОВРЕМЕННЫЕ ТЕХНОЛОГИИ
международная научно-практическая конференция | МЦНС «НАУКА И ПРОСВЕЩЕНИЕ»
dialogNode.appendChild (pNode);
let newInputNode = document.createElement ('input');
dialogNode.appendChild (newInputNode);
Это не очень хорошо, потому что концептуально <input> не был заменен на <p> - он просто переместился. Мы не хотим потерять выделение, состояние фокуса и контент из-за воссоздания модели
DOM.
Хотя эту проблему легко исправить, она не часто возникает в приложениях React.
На практике вы редко вызываете ReactDOM.render напрямую. Вместо этого приложения React
обычно разбиваются на следующие функции:
Рис. 5. Функция TestForm
В этом примере нет проблемы, которую мы только что описали. Возможно, будет легче понять,
почему, если мы будем использовать объектную нотацию вместо JSX. Посмотрите на дерево дочерних
элементов article:
Рис. 6. Функция TestForm с деревом дочерних элементов
СОВРЕМЕННЫЕ ТЕХНОЛОГИИ 83
International scientific conference | www.naukaip.ru
Независимо от того, имеет значение showMessage значение true или false, <input> является вторым дочерним элементом и не меняет своего положения в дереве между отрисовками.
Если showMessage изменится с false на true, React будет обходить дерево элементов, сравнивая
его с предыдущей версией по следующей логике:
dialog → dialog: Можно повторно использовать хост-экземпляр? Да - тип совпадает.
(null) → p: необходимо вставить новый экземпляр хоста p.
input → input: можно повторно использовать экземпляр хоста? Да - тип совпадает.
let inputNode = dialogNode.firstChild;
let pNode = document.createElement ('p');
pNode.textContent = 'Text';
dialogNode.insertBefore (pNode, inputNode);
// Теперь состояние ввода не теряется.
let inputNode = dialogNode.firstChild;
let pNode = document.createElement ('p');
pNode.textContent = 'Text';
dialogNode.insertBefore (pNode, inputNode);
//Теперь состояние ввода не теряется.
Списки
Сравнивая тип элемента в той же позиции в дереве, обычно достаточно, чтобы решить, следует
ли повторно использовать или воссоздать соответствующий экземпляр хоста. Но это работает только в
том случае, если дочерние позиции статичны и не меняют порядок.
С динамическими списками мы не можем быть уверены, что порядок всегда будет одинаковым:
Рис. 7. Функция ItemsForm
84 СОВРЕМЕННЫЕ ТЕХНОЛОГИИ
международная научно-практическая конференция | МЦНС «НАУКА И ПРОСВЕЩЕНИЕ»
Если список наших покупок когда-либо будет переупорядочен, React увидит, что все элементы p
и input внутри имеют один и тот же тип, и не узнает, как их переместить. С точки зрения React изменились сами элементы, а не их порядок.
Код, выполняемый React для повторного заказа 10 элементов, будет примерно таким:
for (let i = 0; i <10; i ++) {
 let pNode = formNode.childNodes [i];
 let textNode = pNode.firstChild;
 textNode.textContent = 'Вы купили' + items [i] .name;
}
Таким образом, вместо того, чтобы переупорядочивать их, React эффективно обновляет каждую
из них. Это может создать проблемы с производительностью и возможные ошибки. Например, содержимое первого ввода останется отраженным в первом вводе после сортировки - даже если концептуально они могут относиться к разным продуктам в вашем списке покупок.
Поэтому React просит вас указывать специальное свойство, называемое ключом (key), каждый
раз, когда вы включаете в свой вывод массив элементов:
Рис. 8. Функция ItemsForm с свойством key
Ключ сообщает React, что он должен рассматривать элемент как концептуально одинаковый,
даже если он имеет разные позиции внутри родительского элемента между рендерами.
Когда React видит <p key = "id123"> внутри <form>, он проверяет, содержал ли предыдущий рендер также <p key = "id123"> внутри той же <form>. Это работает, даже если дочерние элементы <form>
изменили свой порядок. React будет повторно использовать предыдущий экземпляр хоста с тем же
ключом, если он существует, и соответственно изменить порядок siblings (братьев и сестер в иерархии
дерева).
Обратите внимание, что ключ актуален только в пределах определенного родительского элемента React, такого как <form>. React не будет пытаться «сопоставить» элементы с одинаковыми ключами
у разных родителей. В React нет идиоматической поддержки перемещения экземпляра хоста между
разными родителями без его повторного создания.
Компоненты
Выше мы описали функции, возвращающие элементы React, например:
СОВРЕМЕННЫЕ ТЕХНОЛОГИИ 85
International scientific conference | www.naukaip.ru
Рис. 9. Компонент TestForm
Их называют компонентами. Они позволяют создавать собственный «набор инструментов» из
кнопок, аватаров, комментариев и так далее. Компоненты - это основа React.
Компоненты принимают один аргумент - хеш объекта. Он содержит «props» (сокращение от
properties («свойства»)). Здесь showMessage - это prop. Они похожи на именованные аргументы.
Рекурсия
Компоненты - это функции, поэтому мы можем их называть следующим образом:
let reactElement = TestForm ({showMessage: true});
ReactDOM.render (reactElement, domContainer);
Однако это не идиоматический способ использования компонентов в среде выполнения React.
Вместо этого идиоматический способ использования компонента - это тот же механизм, который
анализировался раньше - элементы React. Это означает, что вы не вызываете функцию компонента
напрямую, а вместо этого позволяете React позже сделать это за вас:
// {type: TestForm, props: {showMessage: true}}
let reactElement = <TestForm showMessage = {true} />;
ReactDOM.render (reactElement, domContainer);
И где-то внутри React ваш компонент будет вызываться:
// Где-то внутри React
let type = reactElement.type; // Форма
let props = reactElement.props; // {showMessage: true}
let result = type (props); // Что бы ни возвращала форма
Имена функций компонентов по соглашению пишутся с заглавной буквы. Когда преобразование
JSX видит <TestForm>, а не <form>, оно делает сам тип объекта идентификатором, а не строкой:
console.log (<form / >.type); // строка формы
console.log (<TestForm / >.type); // Функция формы
86 СОВРЕМЕННЫЕ ТЕХНОЛОГИИ
международная научно-практическая конференция | МЦНС «НАУКА И ПРОСВЕЩЕНИЕ»
Нет никакого глобального механизма регистрации - мы буквально обращаемся к форме по имени
при вводе <TestForm />. Если TestForm не существует в локальной области видимости, вы увидите
ошибку JavaScript, как обычно с неправильным именем переменной.
Итак, что делает React, когда тип элемента является функцией? Он вызывает ваш компонент и
спрашивает, какой элемент этот компонент хочет отобразить.
Когда React просматривает дерево элементов, он может встретить элемент, тип которого является компонентом. Он вызовет его и продолжит спуск вниз по дереву возвращенных элементов React.
В конце концов, у нас закончатся компоненты, и React будет знать, что нужно изменить в дереве хостов.
Те же правила сверки, которые уже описывались выше, применимы и здесь. Если тип в той же
позиции (как определено индексом и необязательным ключом) изменяется, React отбрасывает экземпляры хоста внутри и воссоздает их.
Контекст
В React мы передаем вещи другим компонентам в качестве свойств. Иногда большинству компонентов требуется одно и то же - например, выбранная в данный момент визуальная тема. Становится
громоздко передавать его через каждый уровень.
В React это решает Context. По сути, это похоже на динамическое определение объема компонентов. Это похоже на абстрактный слой, который позволяет вам поместить что-то сверху, и дать каждому дочернему элементу внизу возможность прочитать это и повторно обработать, когда оно изменится.
Рис. 10. Пример передачи контекста темы
При визуализации NestedChild useContext (ThemeContext) будет искать ближайший
<ThemeContext.Provider> над ним в дереве и использовать его значение.
Если выше нет ThemeContext.Provider, результатом вызова useContext (ThemeContext) будет
значение по умолчанию, указанное в вызове createContext (). В нашем примере это 'light'.
Эффекты
Ранее мы анализировали, что компоненты React не должны иметь заметных побочных эффектов
во время рендеринга. Но иногда необходимы побочные эффекты. Мы можем управлять фокусом, подписываться на источник данных и так далее.
СОВРЕМЕННЫЕ ТЕХНОЛОГИИ 87
International scientific conference | www.naukaip.ru
В React это делается путем объявления эффекта:
Рис. 11. Компонент Counter с применением useEffect
По возможности React откладывает выполнение эффектов до тех пор, пока браузер не перерисует экран. Это хорошо, потому что код, подобный подписке на источники данных, не должен мешать
времени на интерактивность и времени на первую отрисовку.
Эффекты не запускаются один раз. Они запускаются как после того, как компонент впервые показан пользователю, так и после его обновления. Эффекты могут закрывать текущие свойства и состояние, например, с помощью count в приведенном выше примере.
Эффекты могут потребовать очистки, например, в случае подписок. Чтобы очистить себя, эффект может возвращать функцию:
 useEffect (() => {
 DataSource.addSubscription (handleChange);
 return () => DataSource.removeSubscription (handleChange);
 });
React выполнит возвращенную функцию перед применением этого эффекта в следующий раз, а
также перед уничтожением компонента.
Иногда повторный запуск эффекта на каждом рендере может быть нежелательным. Вы можете
указать React пропустить применение эффекта, если некоторые переменные не изменились:
 useEffect (() => {
 document.title = `Вы нажимали $ {count} раз`;
 }, [count]);
Однако часто это преждевременная оптимизация и может привести к проблемам, если вы не
знакомы с тем, как работают замыкания JavaScript.
Например, в этом коде есть ошибки:
 useEffect (() => {
 DataSource.addSubscription (handleChange);
 return () => DataSource.removeSubscription (handleChange);
 }, []);
88 СОВРЕМЕННЫЕ ТЕХНОЛОГИИ
международная научно-практическая конференция | МЦНС «НАУКА И ПРОСВЕЩЕНИЕ»
Это ошибочно, потому что [] говорит: «Никогда не повторяйте этот эффект повторно». Но эффект
закрывается через handleChange, который определен за его пределами. И handleChange может ссылаться на любые props или состояние:
 function handleChange () {
 console.log (count);
 }
Если мы никогда не позволим эффекту запускаться повторно, handleChange будет продолжать
указывать на версию из первого рендеринга, а count внутри нее всегда будет равен 0.
Чтобы решить эту проблему, нужно убедиться, что если указать массив зависимостей, он включает в себя все, что может измениться, включая функции:
 useEffect (() => {
 DataSource.addSubscription (handleChange);
 return () => DataSource.removeSubscription (handleChange);
 }, [handleChange]);
Статический порядок использования
Вы можете рассматривать useState как синтаксис для определения «переменной состояния
React». Конечно, это не совсем синтаксис, т.к код все еще пишем на JavaScript. Но мы смотрим на
React как на среду выполнения, и поскольку React адаптирует JavaScript для описания деревьев пользовательского интерфейса, его функции иногда находятся ближе к языковому пространству.
Если бы использование было синтаксисом, было бы разумно использовать его на верхнем
уровне:
Рис. 12. Использование useState с условием
СОВРЕМЕННЫЕ ТЕХНОЛОГИИ 89
International scientific conference | www.naukaip.ru
Состояние React является локальным для компонента и его идентификатора в дереве. Если бы
использование было реальным синтаксисом, имело бы смысл охватить его также и верхним уровнем
компонента:
component Example (props) {
 // Действителен только здесь
 const [count, setCount] = useState(0);
 if (условие) {
 // Это будет синтаксическая ошибка
 const [count, setCount] = useState(0);
 }
Это похоже на то, как импорт работает только на верхнем уровне модуля.
React ожидает, что все вызовы хуков происходят только на верхнем уровне компонента и безоговорочно. Эти правила хуков могут быть реализованы с помощью подключаемого модуля линтера.
Внутри хуки реализованы в виде связанных списков. Когда вы вызываете useState, мы перемещаем указатель на следующий элемент. Когда мы выходим из кадра «дерево вызовов» компонента,
мы сохраняем там результирующий список до следующего рендеринга.
Ниже можно увидеть примерный псевдокод реализации хука useState:
Рис. 13. Псевдокод реализации хука useState
Примерно так каждый вызов useState() получает правильное состояние.
Таким образом, были проанализированы многие важные аспекты среды выполнения React. У
React в настоящее время нет хорошей истории для многопроходного рендеринга, то есть когда родительскому рендерингу нужна информация о дочерних элементах. Кроме того, для API обработки ошибок еще нет версии хуков. Возможно, эти две проблемы можно решить вместе.