При обработке изображений одной из центральных является задача 
распознавания заданных объектов. Алгоритмы обработки изображений все 
чаще используются в научных и прикладных исследованиях в различных 
областях человеческой деятельности [1]. В связи с этим, задачи анализа 
изображений - одни из наиболее важных при обработке изображений. С 
помощью алгоритма распознавания круглых контуров можно выявить 
количество газовых пор в сварных швах на фотографии [2].
Анализ литейных предприятий показывает, что производство отливок 
терпит значительные убытки от брака литья - многомиллиардные [3].
Процесс разрушения деталей машин начинается с образования на их 
поверхностях микроскопических трещин [4]. В большинстве случаев 
дефекты имеют вид округлых пятен, но встречаются и крупные скопления 
дефектов разнообразной формы [5]. Человек, занимающийся подсчетом этих пятен на фотографии, тратит большое количество времени. При этом, в силу 
человеческого фактора, возможна погрешность при расчете [6].
Использовав данную систему автоматизации, можно значительно 
сэкономить время, а также минимизировать количество ошибок.
Предложенный метод по обработке изображений будет состоять из 
нескольких основных этапов.
Этап 1. Преобразование цветового пространства – перевод 
изображения из RGB в оттенки серого, при этом на выходе получаем
одноканальную версию изображения [7]. В нашем случае используем 
взвешенный метод. Использование данного метода необходимо для 
целесообразного распределения цветов на входящем изображении. Если мы 
будем использовать метод среднего значения – качество выходного 
изображения после обработки может быть несколько хуже.
Например, при средних значениях цветов, равных 33%, некоторые 
изображения могут казаться намного темнее, чем ожидалось, и поэтому, в 
нашем случае, некоторые газовые поры могут не проявиться после 
преобразования.
Исходя из этого, формула преобразования из RGB в оттенки серого 
имеет вид: 
где R, G, B – основные цвета аддитивной модели.
Эти три конкретных коэффициента представляют сосредоточение 
цветов на изображении в процентном соотношении.
Этап 2. Удаление шума с помощью пороговой функции [8]. После 
получения изображения с оттенками серого, необходимо отфильтровать 
изображение, убрав на нем шумы, то есть убрать слишком большие значения 
или слишком маленькие значения в одноканальном массиве [9]. 
Функция порогового значения имеет вид:
где maxval – это максимальное значение одноканального массива.
Функция применяет пороговое значение, и, если оно превысит данный 
порог, функция применит фильтр к нему.
Этап 3. Устранение дефектов изображения. Получив отфильтрованное 
изображение посредством пороговой функции, можно наблюдать в 
некоторых местах пересвечивание пикселей или же, наоборот, затемнение. 
Поэтому необходимо сгладить перепады соседних пикселей.
Для решения данной проблемы воспользуемся двухсторонним 
фильтром. Двухсторонний фильтр вычисляет средневзвешенное значение 
пикселей в окрестности, в котором вес уменьшается с расстоянием от центра 
соседства. Близкие пиксели, вероятно, будут иметь одинаковые значения, и 
поэтому целесообразно усреднять их вместе.
Этап 4. Бинаризация изображения – приведение изображения к 
такому виду, когда каждый пиксель кодируется либо единицей, либо нулем. 
Этот шаг необходим, так как некоторые последующие функции OpenCV 
используют бинарное изображение, как один из аргументов [10]. Выбор 
порога сегментации выполняется по методу Оцу. Так как после предыдущего 
шага на изображении присутствуют два класса пикселей: фоновые и 
объектные, – метод Оцу подходит для определения границы бинаризации 
лучше: выше будет межклассовая дисперсия. В итоге получим следующее 
изображение, которое продемонстрируем на рисунке 1.
Алгоритм выделения границ, или иначе - обнаружения границ 
работает после того, как качество изображения улучшено перечисленными 
выше методами. При обнаружении краев мы находим границы или края 
объектов в изображении, определяя, где яркость изображения резко 
меняется. Обнаружение краев может быть использовано для извлечения 
структуры объектов в изображении. Если мы заинтересованы в количестве, 
размере, форме или относительном расположении объектов на изображении,
обнаружение краев позволяет нам сосредоточиться на наиболее полезных 
частях изображения, игнорируя части изображения, которые нам не помогут.
После того, как края объектов в изображении были найдены, можно
использовать полученную информацию для поиска контуров изображения.
Этап 5. В OpenCV используется алгоритм топологического 
структурного анализа бинарных изображений. Алгоритм предполагает 
нахождение контуров с учетом вложенности, то есть способен определить, 
когда в контур одного объекта вложен другой.
С помощью полученных контуров можно вести подсчет количества 
объектов на изображении, проводить измерения размеров объектов, 
классифицировать их формы.
Для разработки приложения будем использовать библиотеку 
компьютерного зрения и машинного обучения с открытым исходным кодом 
OpenCV. Данная библиотека предполагает поддержку интерфейсов на 
различных языках, включая язык программирования Python.
Прежде всего необходимо выполнить установку библиотеки cv2 с 
помощью пакетного менеджера pip.
После установки удостоверимся в работоспособности библиотеки, 
импортировав ее, а далее применим функционал считывания изображения. 
Функция imread загружает изображение из указанного файла и возвращает 
его. В нашем случае файл будет храниться в корневой директории.
Отобразим наше изображение в десктопном окне, где будем 
проводить бинаризацию с помощью ползунка. У данного ползунка будет 
порог 255, потому что в дальнейшем будет использоваться пороговая 
функция threshold, все пиксели, которые темнее 127, заменены на 0, а все, 
которые ярче 127, - на 255. На выходе получим черно-белое изображение.
Далее, функция конвертирования цветов cvtColor () преобразует 
входное изображение из одного цветового пространства в другое. В случае 
преобразования из цветового пространства RGB, порядок каналов должен 
быть указан явно (RGB или BGR). Цветовой формат по умолчанию в OpenCV 
часто упоминается как RGB, но на самом деле это BGR (байты обращены). 
Таким образом, первый байт в стандартном (24-битном) цветном изображении будет 8-битным синим компонентом, второй байт будет 
зеленым, а третий байт будет красным. Четвертый, пятый и шестой байты 
будут вторым пикселем (синий, зеленый, красный).
Далее нам следует установить порог серого изображения. Исходя из
приведенных аргументов, будет проводиться бинаризация изображения.
Пройдя бинаризацию, необходимо воспользоваться алгоритмом 
выявления границ, так как в срезе металла возможны наложения дефектов 
друг на друга. OpenCV предоставляет функцию для устранения проблемы. 
Данная функция реализует многоступенчатый подход обнаружения краев. 
После применения алгоритма обнаружения краев произведем поиск контуров 
с помощью функции findContours (). Из функции следует, что мы собираемся 
сгруппировать контуры в многоуровневую иерархию и применить к ним
метод аппроксимации.
Разработанный алгоритм по диагностике усадочных дефектов был 
протестирован и сравнен с ручным методом подсчета, при котором 
специалисты вручную подсчитывали количество дефектов на металлическом 
бруске на производстве. Также ручной метод был применен в идеальных 
условиях для абсолютно точного подсчета.
Было проведено несколько экспериментов, причем в ходе каждого 
эксперимента применялось три метода: ручной метод, ручной метод в 
идеальных условиях и метод распознавания с помощью компьютерного 
зрения. Для обычного ручного метода были взяты подсчеты трех разных 
специалистов и приведены к среднеарифметическому показателю. 
Проведем сравнительную характеристику трех методов, отобразив 
результаты на графике. Для исследования были взяты детали с 
приблизительно одинаковой площадью поражения, чтобы избежать большой 
разницы между замерами. По оси y укажем количество дефектов, по оси x -
количество замеров.
Исходя из графика, можно сделать вывод, что метод OpenCV в 
основном недосчитывал количество дефектов, в отличие от ручного метода с 
идеальными условиями. Прежде всего, это связано с засвечиванием пикселей 
на изображении при использовании фотооборудования. Что касается 
обычного ручного метода, здесь можно наблюдать как недосчет, так и 
пересчет усадочных изъян, при этом погрешность намного больше. Для 
ручного метода погрешность составляет 12.7%, для OpenCV – 3.4%. 
Алгоритм OpenCV показывает нам значительное повышение точности и 
минимизацию погрешностей.
Разработанный алгоритм распознавания дефектов на металлических 
телах позволяет определять контуры на изображении, что значительно 
облегчает процесс подсчета.
В нынешний момент алгоритм распознавания контуров библиотеки 
OpenCV отличается высокой точностью, что помогает избавиться от 
погрешности при анализе.
Эксперименты по проведению автоматизированного распознавания 
дефектов выполнялись с помощью программного обеспечения Python 3.7 с 
использованием библиотеки OpenCV. Результаты программной реализации продемонстрировали работоспособность и эффективность данного 
алгоритма.

