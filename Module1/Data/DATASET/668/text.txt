На сегодняшний день использование фреймворков является неотъемлемой частью
разработки веб-приложений. Фреймворки позволяют разработчикам ускорить и
упростить процесс создания приложений, поскольку они предоставляют готовые
инструменты и библиотеки, которые можно использовать для решения типовых задач.
Одним из таких фреймворков является React.
React – это один из популярных JavaScript-фреймворк для создания
пользовательских интерфейсов. Его основная концепция – виртуальный DOM, который
отображает изменения состояния в поддеревья узлов. Механизм согласования React
запускается и сравнивает предыдущую модель пользовательского интерфейса с новой,
определяет, что изменилось и меняет только то, что необходимо в настоящем DOM,
минимизируя таким образом количество манипуляций с DOM [1].
При разработке веб-приложений необходимо предусматривать возможность
хранения и обработки данных, которые могут динамически изменяться в процессе
работы приложения. Контроль состояния является одной из ключевых характеристик,
необходимых при разработке веб-приложений. При правильной организации управления
состоянием упрощается процесс разработки и обеспечивается масштабируемость
приложения, позволяющая эффективно управлять сложностью приложения и
уменьшить нагрузку на серверные ресурсы [2].
Цель работы – оценить производительность различных подходов и инструментов
для управления состоянием, а также сравнение их преимуществ и недостатков.
Проведение такого исследования может помочь разработчикам в выборе подходящих
технологий и инструментов для управления состоянием в веб-приложениях на React, что
может ускорить процесс разработки и обеспечить оптимальную производительность
приложения.
Для управления состоянием дерева компонентов в веб-приложениях используются
специальные библиотеки – стейт-менеджеры. Redux и Mobx являются наиболее
популярными решениями в React-приложениях. Помимо библиотек популярным
подходом является использование React Context & React Hooks [3]. Состояние – это
концепция, которая позволяет создавать компоненты React, способные хранить данные
и при изменении этих данных автоматически обновлять представление. Данные вприложении могут передаваться между компонентами без использования
дополнительных инструментов. Однако программное приложение проявляет тенденцию
к увеличению структурной и функциональной сложности с течением времени,
сопровождающуюся возросшей взаимосвязанностью и увеличением количества
компонентов, модулей или функциональных элементов, в контексте этого аспекта
передача данных между родительскими и дочерними компонентами через цепочку
вложенности может привести к перегрузке компонентов информацией. Для решения
этой проблемы можно использовать стейт-менеджеры, такие как Redux, MobX, либо
встроенный в React инструмент Context API.
Стейт-менеджер Redux используется для управления состоянием приложения и
обеспечивает контроль за потоком данных [4]. В его основе лежит разделение
приложения на несколько частей, включая:
- хранилище (Store), которое содержит единое хранилище состояния
приложения;
- редьюсер (Reducer), который является функцией, обновляющей состояние
приложения;
- представления (Views), которые отвечают за отображение интерфейса
приложения;
- действия (Actions), которые описывают пути изменения состояния
приложения.
Таким образом, при использовании данного архитектурного паттерна (рис. 1)
приложение структурируется на более мелкие компоненты. Вся логика работы с
данными вынесена в Store и Reducer, тогда как Views предназначены для отображения
информации пользователю, а Actions позволяют контролировать изменение состояния
приложения [4].
Архитектура Redux
Еще одним популярным инструментом является библиотека MobX. Его
архитектура строится на основе трех основных элементов:
– наблюдаемые объекты (observables) – это объекты, за изменениями которых
MobX следит и автоматически обновляет соответствующие компоненты React;
– действия (actions) – это функции, которые изменяют состояние наблюдаемых
объектов;
– реакции (reactions) – это функции, которые автоматически вызываются при
изменении наблюдаемых объектов. Реакции могут быть использованы для обновления
других наблюдаемых объектов или для выполнения других действий.
Кроме того, в MobX есть сущность "computed", которая позволяет отслеживать
изменения в observable данных. Одним из основных преимуществ MobX является то, что
только те данные, которые были вычислены в функции с декоратором "computed" и затем
возвращены в качестве результата, отслеживаются. Это позволяет оптимизировать
процесс перерисовки виртуального DOM [5].
Общая идея архитектуры MobX (рис. 2) заключается в том, чтобы использовать
наблюдаемые объекты для хранения состояния приложения, действия для изменения
этого состояния и реакции для автоматического обновления пользовательского
Помимо библиотек управления состоянием приложения существует встроенный в
React инструмент Context API – это механизм передачи данных вниз по дереву
компонентов без необходимости передавать пропсы вручную на каждом уровне. Он
позволяет создать глобальное состояние, к которому можно получить доступ и изменить
любой компонент из любого места приложения [6].
Архитектура React Context API основана на том, что есть объект контекста,
который может содержать глобальное состояние приложения и доступен для всех
компонентов в дереве компонентов [6].
В процессе разработки и усложнения приложения могут возникнуть различные
проблемы, такие как медленное время компиляции и загрузки, сложность отладки,
низкая производительность, множественные перерисовки, ошибки и сбои, а также
низкая масштабируемость. Вследствие этого основными критериями сравнения
технологий управления состоянием были выбраны:
– производительность: числовые характеристики, описывающие скорость
работы приложения, потребление ресурсов компьютера и отзывчивость интерфейса;
– размер и сложность кода: глубина вложенности, число зависимостей, число
функций, число операторов, число строк кода (без комментариев и пустых строк);
– тестируемость: удобство и эффективность тестирования приложения, наличие
специальных инструментов тестирования для каждой из технологий.
Выбор этих критериев обусловлен их важностью для разработки веб-приложений.
Производительность важна, так как пользователи ожидают быстрых откликов от
приложений. Размер и сложность кода влияют на поддержку и расширяемость
приложения в долгосрочной перспективе. Тестируемость важна для обеспечения
качества кода и быстрой обратной связи в процессе разработки.
Для проведения оценки по выбранным критериям были разработаны два тестовых
веб-приложения с использованием библиотеки React разной сложности, с учетом
различных аспектов, таких как количество компонентов, свойств, логика
взаимодействия и нагрузка на систему. Для каждого приложению была реализована
система управления состоянием в рамках Redux, MobX и React Context & React Hooks.
Первое тестовое приложение – ToDo App (рис. 3) представляет собой простой
менеджер для создания списка задач. В рамках использования ToDo App пользователь
может добавлять, редактировать и удалять задачи, а также отмечать их выполнение.
Второе тестовое приложение – оконный менеджер Window App (рис. 4),
позволяющий разделять окно на несколько частей по вертикали или горизонтали. В
приложении реализована функциональность добавления открывающихся окон, ставней
с регулируемым размером, а также отображения погоды за окном в режиме реального
времени. Для этого приложение использует открытое API для получения данных о
погоде и выводит их на экран.Для каждого из тестовых приложений были проведены измерения
производительности, анализ размера и сложности кода, а также оценка удобства и
эффективности тестирования с использованием различных систем управления
состоянием.
Для реализации эксперимента по оценке производительности было проведено 10 циклов тестирования, в рамках которых были измерены метрики производительности с
использованием библиотеки Puppeteer. Puppeteer является инструментом разработки,
предоставляющим возможность автоматизированного взаимодействия с веб-браузером,
включая выполнение действий пользователя, навигацию по страницам, выполнение
JavaScript-кода и другие функции. Каждый цикл тестирования включал набор
определенных действий, таких как загрузка приложения и взаимодействие с
интерфейсом, симулирующие реальное использование приложения. В процессе
выполнения тестов были измерены различные показатели производительности, такие
как время загрузки страницы, время отклика интерфейса при взаимодействии с
пользователем, использование ресурсов системы.
Для измерения размерности и сложности кода было использовано абстрактное
синтаксическое дерево (AST), которое представляет собой структуру, отражающую
синтаксис и структуру программного кода. Анализ AST позволяет получить
информацию о структуре и сложности кода, такую как количество файлов, модулей,
классов, функций, методов и других конструкций языка программирования. Для обхода
узлов дерева и извлечения информации были использованы методы TypeScript, который
предоставляет инструменты для работы с AST.
Данный эксперимент позволил получить научно обоснованные данные о
производительности, размере и сложности кода тестовых приложений.
Для анализа производительности приложений были рассчитаны числовые
параметры, описывающие скорость работы приложения, использование ресурсов
компьютера и отзывчивость интерфейсаИз анализа графиков производительности приложений можно сделать вывод, что
React Context эффективнее для простых приложений, но с увеличением сложности
приложения преимущество переходит к MobX, особенно если требуется частое
изменение состояний. В случае, если приложение имеет сложную бизнес-логику и
нуждается в точном управлении состоянием, то Redux может оказаться наиболее
подходящим инструментом. Также можно обратить внимание, что, в случае небольшого приложения, выбор технологии не влияет на среднее потребление памяти, однако в
больших приложениях React Context требует меньше памяти в сравнении с остальными.
Результаты оценки размера и сложности кода представлены на таблице.Проанализировав таблицу, можно сделать вывод, что использование Redux в
простом приложении излишне, поскольку на большое количество строк кода приходится
малое количество функций и операторов. В случае большого приложения MobX требует
меньше функций, строк кода и операторов, что является его преимуществом при
реализации решения.
Для проведения анализа связи метрик кода и производительности приложений,
необходимо определить коэффициент корреляции Пирсона между этими двумя
наборами данных. По данным таблицы можно провести анализ связи метрик кода и
производительности только в пределах одного типа приложения, так как данные не
связаны друг с другом.
Для ToDo приложения:
- время рендеринга имеет слабую отрицательную корреляцию с числом
зависимостей (-0,44) и числом функций (-0,46);
- время загрузки страницы имеет слабую отрицательную корреляцию с числом
зависимостей (-0,39) и числом функций (-0,40);
- время первой отрисовки, время добавления нового элемента и потребление
памяти не коррелируют с метриками кода.
Для WindowApp приложения:
– время первой отрисовки имеет слабую положительную корреляцию с числом
операторов (0,32) и числом строк кода (0,33). Это означает, что с увеличением
количества операторов и строк кода время первой отрисовки также увеличивается, но
связь между ними не сильная;
– время рендеринга имеет слабую положительную корреляцию с числом
функций (0,38) и числом строк кода (0,36). Аналогично времени первой отрисовки,
увеличение количества функций и строк кода связано с увеличением времени
рендеринга, но связь не сильная;
– потребление памяти имеет слабую положительную корреляцию с числом
зависимостей (0,34), числом функций (0,37), числом операторов (0,36) и числом строк
кода (0,34);время загрузки страницы не коррелирует с метриками кода;
– время добавления нового элемента имеет сильную положительную
корреляцию с числом операторов и числом строк кода. Это означает, что с увеличением
количества операторов и строк кода время добавления нового элемента значительно
увеличивается.
В целом, результаты анализа связи метрик кода и производительности приложений
показывают, что увеличение метрик кода может привести к увеличению времени
выполнения некоторых задач и потребления памяти.
Каждая из технологий управления состоянием имеет свои особенности в
тестировании. Redux предлагает набор инструментов для тестирования, таких как Redux
Mock Store и Redux Test Utils, что упрощает создание автоматических тестов для
действий (actions), редюсеров (reducers) и селекторов (selectors) с использованием
библиотеки Jest. Тем не менее, использование этих инструментов может потребовать
дополнительного кода, что может затянуть процесс тестирования. MobX предлагает
более простой подход к управлению состоянием, что облегчает процесс тестирования. С
помощью Jest и Enzyme можно легко создавать тесты для MobX компонентов. Однако,
из-за динамической природы MobX, тестирование может быть сложнее, чем в Redux.
React Context и React Hooks не предоставляют специальных инструментов для
тестирования, но благодаря простому синтаксису и отсутствию необходимости
использовать дополнительные инструменты, тестирование может быть выполнено
быстрее и проще, чем в Redux или MobX.
Сравнительный анализ технологий управления состоянием показал, что все три
технологии - Redux, MobX и React Context с использованием React Hooks - обладают
определенными преимуществами и недостатками.
В частности, при сравнении производительности тестовых приложений, было
обнаружено, что в рамках просто приложения имеет преимущество React Context, а
Redux и MobX показали лучшие результаты при использовании в более сложном
приложения.
В аспекте размера и сложности кода React Context с использованием React Hooks
был лидером в небольших приложения, тогда как в более сложном приложении
лидерство перешло к MobX. Redux является избыточным в небольших приложениях.
MobX и Redux являются наиболее удобными технологиями для тестирования
благодаря тому, что имеют более явную и предсказуемую структуру и взаимодействие
между компонентами, а также специальные библиотеки.
Итоговый выбор технологии управления состоянием в React приложении будет
зависеть от требований и задач конкретного проекта. Если у проекта высокие требования
к производительности и есть необходимость к быстрому внедрению в проект стейтменеджера, то MobX будут более предпочтительными. Если же масштабируемость то
Redux. Если же размер кода и простота являются важными факторами, то лучше
использовать React Context. Однако, в любом случае, необходимо учитывать
возможности тестирования и легкость сопровождения кода