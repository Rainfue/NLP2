Следование какой-либо архитектуре CSS облегчает обработку задач
командам. Один разработчик может работать над стилями, связанными с
типографикой, а другой может сосредоточиться на разработке компонентов
сетки. Команды могут разделить работу разумно и повысить общую
производительность.
БЭМ
БЭМ – это методология, разработанная компанией «Яндекс» для своих
внутренних проектов. Название означает «Блок, элемент, модификатор». Методология БЭМ работает с понятиями. В первую очередь контент
страницы состоит из блоков. Затем блоки включают в себя элементы,
представляя связь между друг другом.
Такая схема именования позволяет четко передать связь между
элементами и блоком, к которому они принадлежат, не смотря в разметку
HTML. Из Рисунка 1.1 следует, что элемент header, находится в блоке card.
Также такое именование помогает изолировать действие стилей,
примененных к данному селектору и избавиться от непредсказуемых
последствий каскада.
Что касается модификатора – это селектор, который изменяет или
расширяет правила стилей для блока или элемента, в зависимости от какихлибо внешних воздействий (Рисунок 1.2). Обычно отделяется от элемента с
помощью символа “_” или “--”.
OOCSS
OOCSS означает объектно-ориентированный CSS (Object-Oriented CSS).
В этот подход заложены две основные идеи:
• Разделение структуры и оформления
• Разделение контейнера и контента (содержимого)С помощью такой структуры разработчик получает общие классы,
которые можно использовать в разных местах.
Таким образом достигается уменьшение количества кода за счет
повторного его использования (принцип DRY). Но появляется проблема с
поддержкой: при изменении стиля конкретного элемента часто приходится
менять не только CSS (т.к. большинство классов общие), но и добавлять
классы в разметку.
Кроме того, сам подход OOCSS предлагает не конкретные правила, а
абстрактные рекомендации, поэтому метод достаточно сложен для
применения на практике.
Зато, как это иногда случается, некоторые идеи OOCSS вдохновили
авторов на создание своих, более конкретных, способов структурирования
кода — своеобразных форков OOCSS.
SMACSS
SMACSS расшифровывается как «масштабируемая и модульная
архитектура для CSS» (Scalable and Modular Architecture for CSS).
Основная цель подхода — уменьшение количества кода и упрощение
его поддержки.
Понятия, которые вносит данный метод:
•Base rules — базовые стили. Это стили основных элементов сайта —
body, input, button, ul, ol и т.п. В этой секции используются в основном
селекторы тэгов и атрибутов, классы — в исключительных случаях.
• Layout rules — стили макета. Здесь находятся стили глобальных
элементов, размеры шапки, футера, сайдбара и тому прочее. Предлагается
использовать id в селекторах, так как эти элементы не будут встречаться
более одного раза на странице. Однако это считается плохой практикой.
• Modules rules — стили модулей, то есть блоков, которые могут
использоваться несколь-ко раз на одной странице. Для классов модулей не рекомендуется использовать id и селекторы тэгов (для многократного
использования и независимости от контекста соответственно).
• State rules — стили состояния. В этом разделе прописываются
различные состояния мо-дулей и скелета сайта. Это единственный раздел, в
котором допустимо использование ключевого слова «!important».
• Theme rules — оформление. Здесь описываются стили оформлений,
которые со временем, возможно, нужно будет заменить.
Также рекомендуется вводить неймспейсы для классов, принадлежащих
к определенной группе, а также использовать отдельный неймспейс для
классов, используемых в JavaScript.
Этот подход действительно позволяет упростить написание и поддержку
кода и в последнее время привлекает достаточно большое количество
разработчиков.
Atomic CSS, редко также ACSS — атомарный CSS. В некотором роде
этот подход представляет собой OOCSS, возведенный в абсолют.
При использовании такого подхода для каждого повторно
используемого свойства должен быть сформирован отдельный класс.
Пример: стиль «margin-top: 1px» предполагает создание класса «mt-1px»,
стиль «width: 200px» создание класса «w-200px».
Такой стиль позволяет минимизировать объем CSS-кода за счет
повторного использования деклараций, а также сравнительно легко вводить
изменения в модули, к примеру, при изменении технического задания.
Однако у этого подхода есть существенные недостатки:
• наименования классов представляют собой описательные названия
свойств, не описывая семантическую сущность элемента, что иногда может
усложнить разработку;
• настройки отображения элементов переносятся непосредственно в
HTML.