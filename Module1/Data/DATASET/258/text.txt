Каждый год миллионам микропроцессоров и микроконтроллеров находится применение в качестве центрального управляющего модуля как
для персональных компьютеров, так и для так называемых «интеллектуальных» устройств. В их число теперь входят и бытовые (например, принтер или стиральная машина, современная технологичная игрушка, мобильный телефон), и промышленные устройства (системы сбора и контроля
параметров промышленных объектов, системы диагностики). Эти системы
принято называть встраиваемыми или встроенными. Под встроенной компьютерной системой понимается совокупность аппаратного и программного обеспечения, являющаяся неотъемлемой частью более крупной системы
и используемая для управления и/или непосредственного мониторинга этой системы с применением специальных аппаратных устройств[1]. Обратим внимание, насколько гибким является такое определение – как электронная «начинка» домашнего электроприбора, так и сложный субблок в
системе управления атомной электростанцией одинаково хорошо подпадают под него.
Их можно охарактеризовать как системы с жёсткими ограничениями
на массу, габаритные и энергетические показатели, зачастую устанавливаемые в непосредственной близости от контролируемого объекта. Технический прогресс приводит к тому, что цифровое управление и цифровые
системы охватывают всё большие области человеческой деятельности. Неудивительно, что число таких встраиваемых систем на сегодняшний день
превосходит число персональных компьютеров в сотни и тысячи раз. Об
этом знают специалисты, занимающиеся разработкой и внедрением подобных устройств.
В настоящее время традиционным стал подход, который обусловливает наличие цифрового блока в составе системы; более того, им, как правило, является универсальный, программно управляемый цифровой блок –
микропроцессор или (что чаще) микроконтроллер. По известным причинам
такая схема является наиболее предпочтительной [2].
 Несмотря на ограниченные по сравнению с компьютерами общего
назначения возможности, к встраиваемым системам предъявляются жёсткие требования относительно потребления энергии, времени реакции на
внешние события, предоставляемые возможности. Не случайно появился
класс систем реального времени, обеспечивающий особые показатели по
вышеперечисленным требованиям.
Для обеспечения функционирования сложных систем цифровой обработки
сигналов (ЦОС), таких, например, как системы, реализующие протоколы
беспроводной передачи данных в режиме реального времени, требуются
специальные, адаптированные под определенные приложения, аппаратные
конфигурации. Состав и вид конкретной конфигурации, как правило,
зависит от специфики решаемой задачи, однако каждая из них включает
цифровой блок.
Независимо от состава конфигурации, встраиваемые системы (кроме,
может быть, самых простых) из-за наличия управляемого процессорного
элемента требуют для своего успешного функционирования специального
программного обеспечения – управляющей среды.
Тем не менее, от каждого устройства требуется своя, часто уникальная, функциональность. Вместе с многообразием аппаратных конфигураций это ещё одна причина, по которой управляющее программное обеспечение в каждом случае создается с учетом целевой платформы.
Классическим подходом к построению такого управляющего программного обеспечения был и по-прежнему остается подход, использующий в той или иной степени модель «жесткого цикла». Так называется
модель вычисления качественных и количественных характеристик отклика системы на заданное воздействие, в которой основу алгоритма работы
устройства составляет цикл; на каждом шаге его опрашиваются все источники входных данных для получения исходных величин, результатом обработки которых является выходная величина. Система предстает перед
нами в виде двух моделируемых сущностей – объекта управления и регулятора. (Напомним, что речь здесь идет о цифровом, т.е. дискретном регуляторе.) В качестве вспомогательного, но не отнюдь не обязательного
средства используется математический аппарат теории цифровых конечных автоматов (ЦКА).
Классический подход, совместно с привлечением методики ЦКА,
нашел успешное применение для решения большинства разнообразных
задач, возникающих перед встраиваемыми системами.
В числе его достоинств – полная временная детерминированность
при корректно построенной модели, возможность строго математического
описания ее поведения. Подход, привлекающий ЦКА, дает возможность
описать поведение системы привычными терминами реального мира.
Тем не менее при всех его теоретических положительных качествах,
с практической точки зрения реализация и сопровождение на всех этапах
жизни системы сталкиваются с некоторыми трудностями.
Наибольшей трудностью является именно сопровождение системы –
в случае изменения требований к системе, качественно-количественных
параметров ее функционирования, в том числе и к исходной аппаратной
платформе, модификация управляющей среды крайне неэффективна и ресурсоемка.
Например, в случае появления дополнительного источника входных
данных, включения в модель дополнительного регулятора, адаптировать
цикл системы к новым условиям зачастую невозможно. Аналогично, при
изменении производительности (скорости выполнения элементарных инструкций) цифрового блока необходимо вновь проводить комплексный
пересчет параметров модели.
Естественно, при изменении архитектуры цифрового процессора, переходе на новый процессор, количество вносимых изменений заставляет
отказаться от корректирования среды в пользу полной реконструкции.
Становится гораздо выгоднее просто спроектировать еще одну систему,
чем корректировать и вносить изменения в существующую.
Как правило, в таком случае совершают «откат» назад, к исходной
математической модели, на ее основе строится новая среда – чаще всего с
нуля. Результаты, полученные в ходе эксплуатации предыдущей версии
программ и библиотек – в том числе практические наработки в виде исходных кодов программы – либо не используются, либо коэффициент вовлечения их в рефакторинг (реорганизацию) прототипа оказывается настолько малой, что ее можно не учитывать.
Подобная ситуация связана еще и с тем, что изначально отображение
математических моделей управляемого объекта и регулятора в примитивы
среды осуществляется на чрезвычайно низком уровне, максимально приближенном к аппаратным особенностям платформы (аппаратной организации, времени исполнения машинных команд). В качестве примера можно
привести часто встречающуюся ситуацию организации программной задержки выполнения кода путем подсчета времени, требуемого на исполнение одной машинной инструкции либо некоторому их набору.
Отсутствие промежуточного уровня приводит к нежелательной
«привязке» модели к фиксированной аппаратной конфигурации. Дополнительно этому способствуют преобладание использования языка программирования низкого уровня, чаще всего – языка ассемблера для конкретной
платформы (по нашему мнению – зачастую необоснованное), а также, что
немаловажно – низкая культура программирования и проектирования подобных программных средств [3].
Предлагаемый подход нацелен на использование новой модели построения управляющего программного обеспечения – событийноориентированной. В этом случае – с точки зрения разработки регулятора –
объект управления и система управления (регулятор) рассматриваются как
источник событий, так и их приемники. Адекватная реакция системы на
события объекта обеспечивает корректное поведение объекта управления.
Под термином «событие объекта управления» мы будем понимать
факт изменения состояния объекта управления, информация о котором (об
изменении) может быть передана регулятору. Для каждого конкретного
объекта управления можно определить множество событий и отношения
между ними, такие, например, как правила появления и приоритет. Это
множество будем называть «протоколом».
Важным преимуществом подобного подхода является возможность
применения понятия «контракт» к каждому объявленному протоколу, т.е.
на этапе проектирования строго определить границы подмножества, в котором будут находиться события, актуальные для данного протокола. Реакцию регулятора также весьма желательно сводить в протокол. Однако в
чистом виде такой прием является трудоемким, так как объект управления,
как правило, обладает установившейся структурой, а воздействие на него
регулятора не ограничивается исключительно информационными в их
привычном понимании сигналами – чаще всего объект управления требует
наличия «силовых» воздействий. Поэтому в цепь действия регулятора, которая передает события объекту управления, ставится промежуточное преобразовательное звено, которое теперь может быть описано с использованием понятий «событие» и «протокол событий».
Описание системы в терминах входных и выходных протоколов дает
возможность однозначно спроектировать регулятор, который будет заведомо переносим, т.е. его структура не будет зависеть от структуры управляемого объекта, и – минимально – от конкретного вычислительного модуля, а только от используемых протоколов обмена событиями.
Вспомним, что и в классическом подходе существовало понятие
асинхронной операции и «прерывания». Прерыванием называлось именно
событие источника, информирующее приемник событий о смене состояния
источника. При этом в зависимости от реализации приемник был вынужден приступить к выработке адекватного ответа на данное событие или самостоятельно принять решение о том, чтобы отложить выработку ответа
либо вовсе игнорировать поступившую информацию.
Более того, раннее рассмотренная нами модель – модель с жестким
командным циклом – также может быть представлена в терминах событийно-управляемой модели при следующих посылках: в системе присут-
ствует единственное событие – начало нового кванта времени (цикла модельного времени), реакцией на которое является обновление выходных
величин регулятора. Протокол для него в минимальном варианте описывает периодичность возникновения этого события.
Итак, согласно данному подходу, вся информация распространяется
в системе в виде событий, характеристики которых фиксированы соответствующими протоколами, также определенными разработчиком.
 Теперь события как порции информации является самостоятельной
сущностью. Вполне логичным оказывается следующий шаг, определяющий, что источники и приемники информации в системе также должны
быть самостоятельными, строго определенными сущностями.
Изучение существующих сред [4] и анализ задач, для решения которых они предназначены, указывает на то, что в каждом случае можно выделить такие сущности – отдельные структурные элементы, на которых
основана работа вычислительного модуля.
В подобной библиотеке должны присутствовать такие примитивы,
как наиболее важные структуры данных и алгоритмы-процедуры для работы с ними. При этом правильность работы тем более легко доказать, чем
более универсальным, компактным и легковесным будет эта обособленная
библиотека – микроядро управляющей среды. Корректность работы ядра
есть, на наш взгляд, наиболее важный параметр работы, ведь его отсутствие сводит на нет все остальные преимущества системы.
Даже состоящая из минимального количества примитивов, библиотека ядра представляет собой сложнейший комплекс данных и процедур.
Эксплуатация и проверка ядра может потребовать замены некоторой части
операционной библиотеки для получения дополнительной функциональности, адаптации к новым требованиям по быстродействию или аппаратным ресурсам. Это преимущество, очевидно, у библиотек, более организованных и предоставляющих более структурированный интерфейс. Для таких ядер адаптация к аппаратуре, включая доработку, отладку и тестирование, может быть выполнена максимально быстро.
Немаловажным фактором в пользу такого подхода является возможность модификации существующей системы, так как все примитивы системы являются стандартными, т.е. процедуры включения их в существующие системы или изъятия также являются стандартными.
 Многочисленные примеры сред, а также теоретические исследования в этой области [5] указывают на то, что в составе операционной библиотеки подобного рода весьма желательны следующие компоненты, которые можно условно разбить на три группы:
 - задачи как единицы исполнения (потоки/процессы исполнения в
нашем случае);
 - средства межзадачной коммуникации и синхронизации;
 - средства системного и прикладного интерфейса;
Все эти элементы – примитивы – можно утилизировать, собрав в
операционную библиотеку в виде исходных текстов или уже оттранслированного кода, обеспечив, таким образом, возможность их повторного использования. Эта мера, кроме того, гарантирует исправно работающую, т.е
корректную реализацию данных элементов. Дальнейшее связывание этой
библиотеки с кодом пользовательского приложения обеспечивает получение готовой управляющей среды, часть из которой заведомо корректна.
Кроме того, есть возможность значительно улучшить важный фактор –
скорость разработки и, как следствие, затраты на неё.

