Современное программное обеспечение разрабатывается и поддерживается с использованием систем управления задачами, при этом, пользователи принимают участие в разработке и тестировании, особенно в случае открытого, свободно распространяемого программного обеспечения. Ежегодно пользователи и разработчики проектов создают несколько миллионов отчетов об ошибках (класс bug), описаний желаемых изменений (класс enhancement),
или вопросов по работе с программным обеспечением (класс question) на Github. При этом,
как отмечено в исследовании [1], только 18% из них промаркированы соответствующими
метками.
Использование меток необходимо для эффективного решения задач разработчиками,
т.к. помогает организовать их работу и расставлять приоритеты в проектах. Менеджеры по
продуктам пользуются метками для визуализации особенностей отчетов о проблемах и их
краткого описания или классификации. Также метки можно использовать для фильтрации
таких отчетов по специфическим признакам. При этом, количество немаркированных отчетов о проблемах может достигать нескольких тысяч в одном проекте. Классификация типа
задачи выполняется вручную и является трудоемкой, зачастую требует глубокого понимания
работы программы и знания исходного кода. Автоматическая классификация отчетов о проблемах является актуальной задачей, направленной на снижение трудоемкости разработки и
обслуживания программного обеспечения.
В данном исследовании решалась задача автоматической классификации таких задач
с использованием шести стандартных алгоритмов машинного обучения, а также алгоритма
LogNNet, основанного на технологии резервуарных вычислений [2]. Подробное описание
одной из реализаций алгоритма LogNNet приведено в статье [3]. Для обучения и тестирования использовались две базы данных, одна из которых несбалансированная, а вторая сбалансированная. Подобный подход продиктован тем, что в исследованиях других авторов [4],[5]
были получены низкие результаты по определению класса question на несбалансированных
данных, поэтому в настоящем исследовании ставилась задача проверить может ли балансировка данных в базе влиять на точность классификации отдельных классов.
Несбалансированная и сбалансированная базы были получена из данных исследования [4]. Сначала, набор для обучения и тестовый набор были объединены в одну глобальную
несбалансированную базу данных, содержащую 803417 векторов, каждый из которых содержал 491 признак. Процентное соотношение классов в которой было следующим: bug ≈
50%, enhancement ≈ 41%, question ≈ 9%. Несбалансированная база была получена из глобальной базы случайным выбором 90000 примеров. Соотношение классов в итоговых несбалансированных наборах примерно соответствовало глобальной базе.
Сбалансированная база формировалась следующим образом. Сначала вся доступная
глобальная база данных примеров, полученная через конкатенацию, была разделена на три
отдельных массива данных, каждый из которых содержал примеры только своего класса. Далее из каждого из массивов, случайным образом были выбраны 30000 примеров класса bug,
30000 примеров класса enhancement и 30000 примеров класса question.
Для баз обоих типов были выполнены обучение и тестирование семи классификаторов методом К-фолд (K=5), с расчетом метрик (precision, recall, f1-measure). Для общей
оценки качества классификации мы использовали среднее f1avg «average f1-measure», по аналогии со статьей [6]. Данный эксперимент повторялся 10 раз, затем показатели метрик усреднялись.
Предварительная обработка данных выполнялась следующим образом. Самый первый
этап — это очистка текста, цель которой — уменьшение зашумленности и сокращение числа
признаков в векторе данных.
Очистка текста состояла из удаления следующих признаков и конструкций:
 признаки, состоящие из цифр
 вместо примеров кода, а также других постоянных конструкций, характерных для отчетов о
проблемах, были вставлены строки, обозначающие эти конструкции (например, примеры кода в отчетах заменялись строкой «code_block_token»)
 признаки, состоящие из менее чем трех букв
 признаки, являющиеся стоп-словами
 признаки с частотой менее 1 процента
Вышеперечисленные признаки не имеют «веса» для классификации, т. к. не несут в
себе полезной информации, помогающей определить тот или иной класс отчета о проблеме.
Далее, предварительная обработка данных выполнялась с применением техники «bagof-words» [7]. На основе всех текстов глобальной базы данных строился словарь уникальных
слов (признаков). Каждый текстовый отчет представлялся как набор уникальных слов, для
которых считалось число их вхождений в данный отчет, после чего вычислялся вектор признаков.
С помощью функции CountVectorizer python-библиотеки Scikit-learn [8], мы получили
разреженную матрицу, содержащую 491 признак. Данная матрица была преобразована в соответствии с алгоритмом tf-idf [9], с помощью функции tfidfVectorizer. Вес каждого признака
был взят пропорционально частоте употребления этого слова в тексте отчета и обратно пропорционально частоте его употребления во всех текстах базы данных. Данный алгоритм позволяет оценить важность слова (признака) в контексте документа, являющегося частью коллекции документов.
Результаты расчетов представлены в таблицах 1, 2. Конфигурация LogNNet записана
следующим образом — 491:50:20:3, что означает 491 — размерность входного вектора данных, 50 — второе измерение резервуара, 20 — число нейронов в скрытом слое классификатора, 3 — число классов. 
Для сбалансированной базы данных, для всех алгоритмов показатель f1-меры
больше всего у класса enhancement, на втором месте класс bug, на третьем question. Это говорит о том, что класс enhancement определяется лучше всего, чуть хуже определяется класс
bug, и еще чуть хуже класс question. Такой порядок обусловлен скорее всего особенностями
самих классов (характерные используемые слова и т.п.).
Важно отметить, что класс question определяется гораздо лучше на сбалансированной
базе, чем на несбалансированной, его f1-мера в разы больше. При этом общая точность
(average f1-measure) классификации на сбалансированной базе ниже чем на несбалансированной. Также, показатели f1-меры для классов bug и enhancement выше на несбалансированной базе данных. Таким образом, из-за того, что классы bug и enhancement определяются
хуже на сбалансированной базе, падает и общая точность классификации. Можно предположить, что несбалансированная база сводит задачу классификации от 3х к двум классам, поэтому точность классификации для 2-х классов повышается. Данные результаты объясняют
низкие результаты классификации класса question, наблюдаемые в исследованиях [4],[5], где
была использована несбалансированная база данных. Можно сделать вывод о том, что использование сбалансированной базы данных целесообразно лишь с целью получения лучших
результатов классификации для класса question, но не для получения большей точности
классификации по классам bug и enhancement.
Классификация с применением LogNNet 491:50:20:3 показала результаты пропорциональные результатам других алгоритмов. LogNNet показала приемлемые результаты решения данной задачи как на несбалансированной базе данных (f1avg=0.67), так и на сбалансированной (f1avg=0.59) и оказались лучше результатов алгоритма K-Nearest Neighbors (f1avg=0.57)
и (f1avg=0.50), соответственно.
F1-мера классификации класса question для LogNNet составила 0.12 на несбалансированной базе данных, что говорит об очень низком качестве определения данного класса. Тем
не менее этот показатель выше, чем у алгоритмов Support Vector Machines, Naive Bayes и KNearest Neighbors.
Основное преимущество LogNNet в том, что он позволяет значительно экономить память вычислительного устройства (RAM) [3]. Это позволяет проводит классификацию отчетов налету, используя аппаратные средства с низкими вычислительными ресурсами, микроконтроллеры. Для используемой нами конфигурации LogNNet 491:50:20:3, следуя формулам
из [3], на микроконтроллере типа Arduino потребуется всего 5 кБ RAM. При этом экономия
памяти за счет использования хаотического отображения составит порядка (491 + 1) × 50 × 4
≈ 96 кБ, при условии хранения данных вещественного типа «real».
Также важно отметить, что результаты классификации LogNNet оказались сравнимыми с некоторыми стандартными алгоритмами, используемыми для классификации текстов.
Таким образом, мы можем рекомендовать использовать LogNNet для решения задач классификации отчетов Github и других подобных задач, обученной как на несбалансированной так
и на сбалансированной базах данных, в том числе используя малоресурсные аппаратные
платформы.
Одним из вариантов дальнейшего развития исследования может являться изучение зависимости значений метрик классификации от степени балансировки базы. Также, важно
предложить методики сокращения входного вектора признаков, без значительной потери в
качестве классификации. Это поможет увеличить скорость обработки данных, а также сократит память, необходимую для работы LogNNet с данной задачей. 
