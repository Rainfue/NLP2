В данной работе рассматриваются вопросы программной разработки научной
рекомендательной системы (НРекС). Основным назначением НРекС является удовлетворение
информационных потребностей пользователей (специалистов-предметников) в получении профильных
публикаций по тематикам проводимых исследований. При создании НРекС возникает ряд важных вопросов по выбору системы
управления и организации контента, алгоритмов обработки данных, выработки рекомендаций.
Целесообразно разрабатывать НРекС в виде клиент-серверного веб-приложения, в котором клиент
взаимодействует с веб-сервером при помощи браузера. Данное решение позволяет минимизировать
сложность человеко-машинного общения и дает возможность нескольким пользователям одновременно
работать в НРекС, что может быть полезно в случае организации коллаборативной фильтрации. Наиболее
важно в разрабатываемом приложении предусмотреть выполнение следующих требований:
1) простой пользовательский интерфейс;
2) просмотр и поиск статей, хранящихся в системе;
3) автоматическое поступление новых статей в систему;
4) автоматическое получение рекомендаций.Из вышеназванных требований первое относится к фронтенду (клиентская часть приложения), а
остальные к бэкенду (серверная часть приложения). Именно вопросам применения бэкенд-технологий для
разработки НРекС посвящена данная статья.
Проанализируем трудности, которые возникают при создании серверной части приложения. В
первую очередь отметим, что автоматическая загрузка новых статей оказывает большую нагрузку на
систему. Нагрузка также увеличивается из-за применения методов машинного обучения для
автоматической разметки сообщений и выработки рекомендаций. Для устранения этих проблем в
разрабатываемом приложении эти задачи выносятся в отдельные сервисы, что увеличивает
масштабируемость системы и позволяет располагать реализуемые сервисы на других ЭВМ. Правильный выбор бэкенд-технологий позволяет эффективно реализовать взаимодействие с базой
данных и ускорять выполнение операций на сервере. Рассмотрим основные современные архитектуры
построения веб-приложений: монолитная архитектура, Headless-архитектура и микросервисная
архитектура [1,2,3].
Монолитная архитектура (МА) использует единый код для реализации всех функциональных
возможностей системы. Однако по мере того, как стали появляться новые каналы взаимодействия с
пользователем, единый код, используемый в МА, стал препятствием, не позволяющим быстро проводить
гибкую настройку и внедрять инновационные технологии. Стоит отметить, что добавление в данную
архитектуру отдельных сервисов, является трудно решаемой проблемой.
В связи с возникшими сложностями по адаптации МА к современным прикладным задачам
разработчики программного обеспечения активизировали поиск других решений, основанных прежде
всего на отделении различных функций и реализации их в качестве самостоятельных приложений. Эти
приложения соединяются через интерфейс прикладного программирования (API). Данный подход
реализован в Headless-архитектуре и микросервисной архитектуре, в которых внешний интерфейс
может модифицироваться независимо от серверной части.
Так, в Headless-архитектуре предусматривается раздельное проведение фронтенд и бэкенд
разработки. При этом фронтенд определяет внешний вид системы со стороны пользователя, а бэкенд
обеспечивает внутренний процесс обработки запроса и ответа пользователю. В названии архитектуры
подчеркивается, что бэкенд («тело») не привязано к конкретному фронтенду («голова»).
Микросервисы во многом развивают технологии, заложенные в Headless-архитектуре. При этом в
них происходит не просто разделение бэкенда и фронтенда, но отдельные функции системы программно
реализуются в виде изолированных инструментов – «сервисов», которые подключаются в требуемом
порядке через API. Таким образом, микросервисная архитектура представляет набор независимых
сервисов, каждый из которых отвечает за выполнение конкретной операции. В целом микросервисы
обеспечивают большую гибкость по сравнению с Headless-архитектурой, но при этом возрастет
сложность и стоимость как разработки, так и эксплуатации системы. Поэтому микросервисы обычно
используются в высоконагруженных проектах, предусматривающих одновременное взаимодействие
большого количества пользователей. 