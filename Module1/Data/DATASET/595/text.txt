Что такое линейная алгебра?
Линейная алгебра - это раздел математики, который занимается векторными
пространствами и матрицами. Это математика данных, занимающаяся их созданием,
представлением, преобразованием и потреблением с использованием различных
концепций векторов и матриц. [1]
Необходимость изучения линейной алгебры
В мире науки о данных данные не только представлены в виде векторов и матриц,
но также исследуются и преобразуются с использованием различных концепций линейной
алгебры. Это делает важным знание концепций линейной алгебры, чтобы лучше понять
внутреннюю работу различных моделей и алгоритмов машинного обучения.
Шаг 1
Что такое векторы?
Векторы - это объекты, которые имеют величину и направление. В физике векторы
визуализируются как направленные сегменты линии в векторном пространстве
(совокупность векторов), длина которого является величиной, а стрелка указывает
направление. [2]
В науке о данных векторы определяются как точки в конечномерном пространстве,
которые могут представлять числовые данные. Например, если на веб-сайте электронной
коммерции есть данные о своих клиентах, такие как размер обуви, размер талии и рост,
его можно представить как набор трехмерных векторов (размер обуви, размер талии,
рост). Ниже представлен вектор, представляющий рост 180 см, размер талии 32 см и
размер обуви UK 12 как на рисунке 1.
Рисунок 1 – Представление вектора
Что такое Numpy?
Numpy - это библиотека для числовых вычислений в Python, которая обеспечивает
поддержку многомерных массивов и матриц, а также связанных математических функций.
Массивы Numpy могут быть представлены как векторы. Данный программный код
представит вышеуказанный вектор с помощью массива numpy в соответствии с листингом
1. [3]
Листинг 1 – Вектор в программном коде
# Импорт Numpy
import numpy as np
# Создаём массив с помощью Numpy
v1 = np.array([
[180],
[32],
[12]
])
# Выводим массив в консоль
print(v1)
Для запуска программного кода воспользуемся VS Code и в терминале введем
следующую команду: python3 vector.py в соответствии с рисунком 2.
Рисунок 2 – Запуск кода
Шаг 2
Векторы и система координат
Векторы построены с использованием системы координат. В геометрии система
координат использует одно или несколько чисел или координат для определения
положения точек или других геометрических элементов на многообразии, таком как
евклидово пространство. В евклидовом пространстве вектор v = (2,3) может быть
представлен как 2 единицы по оси x и 3 единицы по оси y. Аналогично, вектор w = (2,3,4)
может быть представлен как 2 единицы по оси x, 3 единицы по оси Y и 4 единицы по оси
z.
Нулевой вектор
Вектор называется нулевым вектором, если все его элементы равны 0. Это также
представлено началом координат в системе координат.
Построение вектора с помощью Matplotlib
Matplotlib - это библиотека визуализации данных для Python, которую можно
использовать для визуализации векторов. [4]
Векторы представлены в виде стрелок при нанесении их положения на график.
Matplotlib предлагает колчанный график для построения векторов. График колчана
принимает в качестве параметров расположение и направление векторов.
Во-первых, давайте изобразим несколько векторов в двух измерениях, как на
рисунке 3.
Рисунок 3 – Измерения векторов
Представим данные вектора в программном коде в соответствии с листингом 2.
Листинг 2 – Создание векторов
# Импорт библиотеки matplotlib
import matplotlib.pyplot as plt
# Определение происхождения или местоположения
# Это определенный кортеж списков
origin = [0],[0]
# Таким же образом задайте векторы (направления)
v1 = [4],[3]
v2 = [-3],[3]
v3 = [5],[6]
# Построение трёх векторов с помощью matplotlib.quiver
plt.quiver(*origin, *v1, color='r', units='xy', angles='xy', scale_units='xy', scale=1,
label='v1 = [4,3]')
plt.quiver(*origin, *v2, color='b', units='xy', angles='xy', scale_units='xy', scale=1,
label='v2 = [-3,3]')
plt.quiver(*origin, *v3, color='g', units='xy', angles='xy', scale_units='xy', scale=1,
label='v3 = [5,6]')
# units, angles, scale_units and scale используются для масштабирования графика.
Ниже с той же целью используются xlim и ylim.
plt.xlim(-8, 8)
plt.ylim(-8, 8)
# Установка места для легенды
plt.legend(loc=2)
plt.xlabel('X')
plt.ylabel('Y')
plt.title("2D представление векторов")
# Сохранение изображения в формате PNG
plt.savefig('2Dvectors.png')
plt.show()
Таким же образом запустим vector.py, используя следующую команду, чтобы
создать визуализацию: python3 vector.py (этот код не выводит никаких данных на
терминал.)
Откроем сформировавшийся файл 2Dvectors.png на боковой панели VS Code в
соответствии с рисунком 4.
Рисунок 4 – Представление векторов
Построение векторов или векторного поля в двух и / или трех измерениях полезно
для инженеров для визуализации электрического потенциала, градиентов напряжений и т.
д.
Построение векторов в 3-х измерениях.
Есть 3 вектора, которые представлены на рисунке 5.
Рисунок 5 - Вектора
Построим данные вектора при помощи программного кода в листинге 3.
Листинг 3 – Создание трехмерных векторов
import matplotlib.pyplot as plt
# mplot3d для 3D-графиков
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(8,8))
origin = [0],[0],[0]
v1 = [2],[1],[0]
v2 = [3],[4],[5]
v3 = [5],[5],[5]
# projection = '3d' для трехмерного графика
ax = fig.add_subplot(111, projection='3d')
ax.quiver(*origin, *v1, color='r', label='v1 = [2,1,0]', arrow_length_ratio=0.2)
ax.quiver(*origin, *v2, color='b', label='v2 = [3,4,5]', arrow_length_ratio=0.05)
ax.quiver(*origin, *v3, color='g', label='v3 = [5,5,5]', arrow_length_ratio=0.05)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_xlim(-6,6)
ax.set_ylim(-6,6)
ax.set_zlim(-6,6)
ax.legend(loc=2)
plt.title("3D-представление векторов")
plt.savefig("3Dvectors.png", dpi=300)
plt.show()
Запусим vector.py, используя следующую команду, чтобы создать визуализацию:
python3 vector.py (этот код не выводит никаких данных на терминал.)
Откроем и просмотрим вновь сформированный файл 3Dvectors.png на боковой
панели VS Code.
Рисунок 6 – Трехмерное представление
Шаг 3
Величина вектора
Величина вектора - это длина вектора. Величина вектора a обозначается как || a ||.
Он рассчитывается по формуле расстояния. Ниже мы вычислим величину вектора
относительно начала координат. Здесь величина - это корень из суммы квадратов
разностей элементов вектора с началом координат в соответствии с рисунком 7.
Рисунок 7 – Величина вектора
Попробуем то же самое в numpy в соответствии с листингом 4.
Листинг 4 – Величина вектора в программном коде
# Импорт numpy
import numpy as np
# Создание вектора
v1 = np.array([5,12,13])
# Вычисление величины с помощью метода linalg.norm()
magnitude = np.linalg.norm(v1)
print("Величина:",magnitude)
Запустим данный программный код командой, которая использовалась ранее.
Единичный вектор
Единичный вектор вектора u - это вектор, который имеет то же направление, что и
u, и имеет величину 1 единицу в соответствии с рисунком 8.
Рисунок 8 – Единичный вектор
Создадим вектор в соответствии с листингом 5.
Листинг 5 – Создание единичного вектора.
# Импорт numpy
import numpy as np
# Создание вектора
v1 = np.array([5,12,13])
# Вычисление величины с помощью метода linalg.norm()
v1_mag = np.linalg.norm(v1)
# Вычисление единичного вектора
v1_unit = v1 / v1_mag
print("Единичный вектор:",v1_unit)
Запустим vector.py с помощью команды: python3 vector.py.
Шаг 4
Сложение векторов
Два или более вектора могут быть добавлены, чтобы сформировать новый вектор.
Для двух векторов v1 и v2, v1 + v2 получается путем размещения двух векторов голова к
хвосту и рисования результирующего вектора от свободного хвоста к свободной голове.
Это параллелограммный закон сложения векторов. Если v1 и v2 - две смежные стороны
параллелограмма, то диагональ, проходящая через общую точку, представляет их сумму
как по величине, так и по направлению.
В системе координат сложение векторов получается простым сложением
соответствующих элементов двух векторов. Есть 2 вектора в соответствии с рисунком 9.
Рисунок 9 – Сумма двух векторов
Попробуем сложить вектора в Numpy в соответствии с листингом 6.
Листинг 6 – Сложение векторов
# Импорт numpy
import numpy as np
v1 = np.array([2,1,0])
v2 = np.array([3,4,3])
# Простое добавление
v12 = v1 + v2
print("v12 = v1 + v2 =",v12)
Запустите vector.py с помощью следующей команды: python3 vector.py.
В соответствии с рисунком 10 представлен график для параллелограммного закона
сложения векторов.
Рисунок 10 – График сложения векторов
Шаг 5
Скалярное умножение векторов
Скаляр - это действительное число, которое, в отличие от векторов, имеет только
величину и не имеет направления. Векторы можно умножить на скаляр. В результате
получается вектор, и этот процесс называется скалярным умножением. Название «скаляр»
происходит от его использования: масштабирование вектора. Есть скалярное
действительное число a и вектор v в соответствии с рисунком 11.
Рисунок 11 – Формула скалярного произведения
Посмотрим на несколько примеров в соответствии с рисунком 12.
Рисунок 12 – Примеры скалярного произведения
Теперь давайте преобразуем приведенные выше примеры в простой код в
соответствии с листингом 7.
Листинг 7 – Скалярное произведение
# Импорт numpy
import numpy as np
# Создание вектора
v = np.array([3,6,9])
print("Вектор v =",v)
# Определение скаляров
a, b, c, d = 2, 1/3, -1, -3
print("a = {}, b = {}, c = {}, d = {}".format(a,"1/3",c,d))
# Выполните скалярное умножение для всех скаляров
av = a * v
bv = b * v
cv = c * v
dv = d * v
# Вывод на терминал результатов
print("av = a * v =",av)
print("bv = b * v =",bv)
print("cv = c * v =",cv)
print("dv = d * v =",dv)
Запустим данный код при помощи команды запуска кода.
Некоторые полезные правила скалярного умножения
По сути, скалярное умножение позволяет индивидуально умножать все элементы
вектора на скаляр. Вот несколько общих правил:
- вектор остается прежним, если скалярное умножение выполняется с +1;
- скалярное умножение на любое положительное целое число, отличное от 1,
изменяет величину вектора, но направление остается прежним в соответствии с рисунком
13.
Рисунок 13 – Графическое представление правил
Скалярное умножение на любое действительное число от -1 до 1 (то есть дроби)
уменьшает величину вектора в соответствии с рисунком 14.
Рисунок 14 – Деление вектора на дробь
Скалярное умножение на любое действительное число меньше -1 и больше 1
увеличивает величину вектора.
Скалярное умножение на -1 меняет направление вектора на противоположное, но
величина остается прежней в соответствии с рисунком 15.
Рисунок 15 – Умножение с отрицательными числами
Скалярное умножение на любое другое отрицательное целое число меняет
направление вектора, а также изменяет его величину.
Шаг 6
Вычитание вектора
Вычитание вектора приводит к вычитанию одного вектора из другого. Есть 2
вектора a и b на рисунке 16.
Рисунок 16 - Вектор
Это показывает, что это особый сценарий сложения векторов a и b, но с обратным
направлением b как на рисунке 17.
Рисунок 17 – Особый случай
Теперь произведем вычисление в соответствии с рисунком 18.
Рисунок 18 – Производимые вычисления
Давайте попробуем это в numpy в соответствии с листингом 8.
Листинг 8 – Вычитание вектора
# Импорт numpy
import numpy as np
a = np.array([2,3,4])
b = np.array([1,2,1])
# Векторы, вычитаемые простым вычитанием
c = a – b
print("c = a - b =",c)
Запустим данный программный код и получим результат на рисунке 19.
Рисунок 19 – Вычитание векторов
Шаг 7
Скалярное произведение
Точечное произведение или скалярное произведение - это сумма произведений
соответствующих элементов двух векторов. Есть 2 вектора на рисунке 20.
Рисунок 20 – Два вектора
Произведение вышеуказанных векторов представлен в соответствии с рисунком 21.
Рисунок 21 – Умножение векторов
Давайте посмотрим на пример использования numpy в соответствии с листингом 9.
Листинг 9 – Программная реализация произведения векторов
# Импорт numpy
import numpy as np
# Создание 2 векторов
u = np.array([1,2,3])
v = np.array([3,5,-2])
# Пример суммы произведений соответствующих элементов обоих векторов
print("Сумма произведений соответствующих элементов = 1*3 + 2*5 + 3*(-2) =",
u[0]*v[0] + u[1]*v[1] + u[2]*v[2])
# Вычислите скалярного произведения с помощью метода dot() и сравнение с
результатом выше.
print("Скалярное произведение u и v =",np.dot(u,v))
Перекрестное произведение
Перекрестное произведение двух векторов u и v - это вектор с направлением,
перпендикулярным обоим векторам u и v. Вектор u x v лежит в плоскости,
перпендикулярной плоскости, в которой лежат векторы u и v. Перекрестное произведение
используется в физике для расчета крутящего момента. Он также используется для
определения ортогональности двух векторов. Также представим в графическом виде
вектора в соответствии с листингом 10.
Листинг 10 – Программная реализация перекрестного произведения
import numpy as np
u = np.array([1,0,3])
v = np.array([3,0,-2])
cross_product = np.cross(u,v)
print(cross_product)
import matplotlib.pyplot as plt
# mplot3d для 3D-графиков
from mpl_toolkits.mplot3d import Axes3D
# Создание фигуры matplotlib
fig = plt.figure(figsize=(8,8))
# Определение происхождение или местоположение
# Это определенный кортеж списков
origin = [0],[0],[0]
# Определение векторов таким же образом
u = [1],[0],[3]
v = [3],[0],[-2]
uxv = [0],[11],[0]
# projection='3d' для трехмерного графика
ax = fig.add_subplot(111, projection='3d')
# Построение 3 векторов с помощью matplotlib.quiver
ax.quiver(*origin, *u, color='r', label='u = [1,0,3]', arrow_length_ratio=0.2)
ax.quiver(*origin, *v, color='b', label='v = [3,0,-2]', arrow_length_ratio=0.1)
ax.quiver(*origin, *uxv, color='g', label='u x v = [0,11,0]', arrow_length_ratio=0.1)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_xlim(-6,6)
ax.set_ylim(-6,6)
ax.set_zlim(-6,6)
ax.legend(loc=6)
plt.title("Построение перекрестного произведения")
# Сохранение изображения в формате PNG
plt.savefig("cross_product.png", dpi=300)
plt.show()
Запустим и просмотрим вновь сформированный файл cross_product.png на боковой
панели VScode. Ясно, что u x v лежит в плоскости, перпендикулярной плоскости, в
которой лежат векторы u и v в соответствии с рисунком 22.
Рисунок 22 – Графическое представление
Таким образом, после рассмотрения большинства операций с векторами можно
сделать вывод, что язык программирования Python имеет в арсенале математические
библиотеки с довольно сильным функционалом, что позволяет уменьшить время на
разработку программных продуктов, в которых необходим математический функционал.