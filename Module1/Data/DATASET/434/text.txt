В современных реалиях фронтенд-фреймворки играют огромную роль при
разработке веб-приложений. Использование готовых решений ускоряет процесс
разработки и, как следствие, сокращает затраты со стороны бизнеса.
Фреймворки стали неотъемлемой частью процесса разработки, поэтому
подвергаются постоянной доработке и усовершенствованию, в том числе оптимизации
скорости работы. В качестве технологии для исследования выбран фреймворк Vue JS:
версии 2 и 3. Существенным изменениям в версии 3 были подвергнуты реактивность и
принципы обновления данных, а главным нововведением Vue 3 стал способ определения
компонентов Composition API.
Vue позиционирует себя как прогрессивный фреймворк. Для быстрой реализации
взаимодействия с пользователем технология использует реактивность. Авторы статьи [1]
отождествляют реактивность с отзывчивостью. Согласно документации, реактивность –
способность компонентов Vue мгновенно реагировать на действия пользователя или
других источников событий [2].
В ядре Vue.js находится система, позволяющая декларативно отрисовывать данные
в DOM с помощью простого синтаксиса шаблонов [2]. Данные и элементы DOM связаны
между собой, благодаря чему DOM перерисовывается, как только в данных происходят
изменения.
Принципы реактивности в разных версиях Vue значительно различаются.
Первостепенно, рассмотрим принципы работы реактивности Vue 2 Options API.
Vue.js преобразует простой JavaScript-объект в реактивный объект с помощью
геттеров и сеттеров, чтобы автоматически отслеживать изменения свойств в шаблоне.
Добавить или удалить свойство в объекте после его инициализации Vue.js возможно
двумя способами:
1. Создать новый объект с добавленным свойством и заменить им оригинальный
объект. Этот метод работает, но требует больше памяти, так как создается новый объект.
2. Использовать метод Vue.set (object, propertyName, value), или его альтернативу
vm.$set, чтобы добавить реактивное свойство во вложенные объекты. Этот способ более
эффективен и гарантирует создание геттеров и сеттеров для нового свойства, тем самым
делая его реактивным.
В Composition API в Vue 3 реактивность достигается при помощи объекта Proxy с
обработчиками для get и set, что позволяет отслеживать изменения, включая
динамическое добавление новых свойств после создания компонента.
Object.defineProperty на такие изменения не реагирует. При этом важно заметить, что
проксируемый объект не эквивалентен оригинальному объекту в строгих сравнениях, и
это может повлиять на операции, которые зависят от строгого сравнения, такие как
Array.includes() или Array.indexOf().
В Options API обращение к реактивным переменным осуществляется через
экземпляр объекта this. В Composition API создать реактивную переменную в можно при
помощи вызова функции ref() или reactive(). Рассмотрим случаи употребления этих
функций:
 создание реактивных переменных при помощи ref() допустимо для объектов и
примитивов, или reactive() только для объектов;
 обращение к переменной с ref() требует .value в конце, reactive() только название
переменной;
 ref() позволяет полностью перезаписать значение, reactive() только изменять
свойства;
 объекты с reactive() теряют реактивность после деструктуризации.
Важным нововведением Vue 3 и Composition API является возможность
переиспользовать код в модулях. Это также означает, что при использовании Composition
API реактивные переменные не привязываются к экземпляру компонента. Их можно
объявлять в модулях, вызывать в нескольких компонентах, и они сохраняют свою
реактивность.
Таким образом, основными отличиями реализации и работы реактивности в двух
версиях фреймоворка являются:
 синтаксис – обращение к this или вызов реактивных функций ref или reactive;
 реактивное обновление объектов и массивов после их инициализации;
 переиспользование реактивных переменных;
 скорость рендеринга и обновления реактивных переменных.
Разница реализации принципов реактивности в Options API и Composition API
напрямую влияет на скорость работы приложения. Предполагается, что использование
Proxy предоставляет более гибкое и эффективное управление объектами и работает
быстрее, чем Object.defineProperty. Рассмотрим разницу реализации реактивности в
Options API и Composition и API на практике с помощью измерения в скорости работы
приложений. Для детального рассмотрения реализации реактивности в версиях Vue 2 и
Vue 3 подготовлены 2 прототипа приложений ToDo List, с использованием Options API и
Composition API соответственно.
Скорость работы обоих способов описания компонента измерялась с помощью
вкладки Vue DevTools Timeline, а также с помощью Google DevTools Performance.
Измерения обоих приложений производились с помощью Google Chrome (Версия
117.0.5938.132), Испытания проводились на оборудовании со спецификациями:
 MacBook Air (M1, 2020), Apple M1, 16GB, SSD 256GB, Операционная система
macOS Monterey 12.1
 MacBook Pro (M1, 2020), Apple M1, 8GB, SSD 512GB, Операционная система
macOS Ventura 13.3.1
Тестирование проводилось по следующему сценарию: измерение времени
рендеринга изменений в компоненте при удалении элемента списка. Выполнение
измерений с помощью инструментов разработчика браузера, а также инструментов
разработчика Vue DevTools. С помощью Vue DevTools измеряется время от момента
обнаружения действия щелчка мыши на кнопке, до момента окончания события,
вызванного кликом. С помощью инструментов разработчика браузера измеряется время от
момента обнаружения действия щелчка мыши на кнопке, переходящей к экрану таблицы,
до момента установки изменений в дереве DOM.
Для расчета времени с помощью Vue DevTools необходимо во вкладке
«Performance» высчитать разницу между временем выполнения клика по кнопке и
удалению элемента из списка или изменению элемента.
Для расчета времени с помощью Google DevTools необходимо вычесть время
начала события клика, которое отображается как «Event: click», из времени конца
отрисовки в DOM. Измерении отрисовки DOM включает в себя такие стадии как
«Recalculate styles», «Pre-Paint», «Paint», «Commit». Включение данных стадий в измерение
позволяет отобразить общее время, затраченное на обработку события и отрисовку
изменений.
Скорость работы веб-приложения является неотъемлемым фактором при
разработке клиентского приложения, так как напрямую влияет на восприятие приложения
пользователями и является ключевым фактором для привлечения и удержания
пользователей на веб-странице.
Результаты исследований показывают разницу в производительности между
Options API и Compositions API при отображении интерфейсов. По результатам
эксперимента заметно, что Vue 3 существенно превосходит Vue 2 по скорости как при
обработке событий vue, так и при отрисовке изменений реактивных элементов DOM.
