Синтаксический сахар является интересной и актуальной темой, которую
должен знать каждый Java программист. Синтаксический сахар - это упрощающие
конструкции или сокращения в языке программирования, которые делают код
более выразительным и удобным для чтения, но не вносят существенных
изменений в его семантику [1].
Цель проекта – изучение основных видов синтаксического сахара,
используемых в различных версиях Java, и демонстрация их использования.
Чтобы продемонстрировать примеры синтаксического сахара в Java, был
написан код (рисунок 1), который считывает имя файла, содержащий числа, и
выводит эти числа в консоль.
Рисунок 1 – Код чтения файла
В предлагаемом коде:
1. Созданы два потока BufferedReader для чтения полного пути и чтения
файла.
2. Получены все числа из файла в виде списка строк.
3. Все строки в списке конвертированы в числа и помещены в новый
числовой список.
4. Все числа в новом списке выведены в консоль.
5. Закрыты потоки BufferedReader.
6. Обработаны исключения NumberFormatException и IOException
Существует огромное количество синтаксического сахара в Java. Авторами
предложены пять наиболее полезных конструкций, которые помогут существенно
сократить количество кода.
Блок Try-with-resources был добавлен в седьмой версии Java. Try-withresources позволяет автоматически закрывать ресурсы, используемые внутри
блока try, после завершения работы с ними. Этот синтаксис упрощает работу с
ресурсами, такими, как потоки ввода-вывода, сокеты или другие ресурсы. В
рассматриваемом примере BufferedReader создаётся в теле try (рисунок 2).
Данная конструкция является неудобной в связи с тем, что закрытие потока
приходится осуществлять вручную, используя метод close (рисунок 3).
Рисунок 2 – Фрагмент кода. Потоки созданы в теле try
Рисунок 3 – Фрагмент кода. Потоки закрыты вручную
Далее потоки были перемещены в блок try-with-resources (рисунок 4). В
результате чего, ресурсы потоков сами освободятся после выполнения блока.
Рисунок 4 – Фрагмент кода. Потоки созданы в блоке try
Multi-catch блок был добавлен в седьмой версии Java. Multi-catch блок
позволяет легко обрабатывать несколько исключений с помощью одного блока
catch. Этот синтаксис упрощает код и улучшает его читабельность, особенно
когда разработчик хочет выполнить одну и ту же обработку для нескольких разных
типов исключений. В примере NumberFormatException и IOException
обрабатываются двумя блоками catch (рисунок 5).
Рисунок 5 – Фрагмент кода. Исключения обработаны в двух блоках catch
Если требуется для нескольких исключений прописать одинаковую
обработку, целесообразнее будет обработать их в одном блоке catch (рисунок 6).
Рисунок 6 – Фрагмент кода. Исключения обработаны в одном блоке catch
Алмазный оператор был введен в седьмой версии Java и представляет
собой синтаксический сахар, который упрощает работу со структурами данных. Он
показывает java какой тип данных необходимо хранить в структуре. В данной
работе используется список, представленный в виде структуры данных (рисунок
7). Изначально в списках хранятся объекты типа Object. Каждый раз, получая
объект из списка, необходимо приводить его к нужному типу данных (рисунки 8, 9).
Рисунок 7 – Фрагмент кода.
Списки созданы без использования алмазного оператора
Рисунок 8 – Фрагмент кода. Строка из списка приводится к типу String
Рисунок 9 – Фрагмент кода. Число из списка приводится к типу int
С использованием алмазного оператора, Java понимает, какой тип данных
необходим (рисунок 10). Поэтому приводить к нужному типу больше не требуется
(рисунки 11, 12). Алмазный оператор упрощает код, делает его более
читабельным и уменьшает вероятность ошибок.
Рисунок 10 – Фрагмент кода.
Списки созданы с использованием алмазного оператора
Рисунок 11 – Фрагмент кода.
Строка из списка не нужно приводить к типу String
Рисунок 12 – Фрагмент кода. Число из списка не нужно приводится к типу int
Цикл for-each представляет собой синтаксический сахар, введенный в
восьмой версии Java, который позволяет упростить итерацию по элементам
коллекций и массивов. Этот вид цикла делает код более читабельным и
уменьшает вероятность ошибок, связанных с использованием индексов. В
представленном коде итерация происходит неудобно из-за наличия индексов
(рисунки 13, 14).
Рисунок 13 – Фрагмент кода.
Итерация по списку происходит в обычном цикле
Рисунок 14 – Фрагмент кода.
Итерация по списку происходит в обычном цикле
Заменим обычные циклы на for-each, и читабельность сразу повысится
(рисунок 15, 16). For-ecah можно читать как обычный текст на английском языке.
Рисунок 15 – Фрагмент кода.
Итерация по списку происходит в for-each цикле
Рисунок 16 – Фрагмент кода.
Итерация по списку происходит в for-each цикле
Лямбда-выражения, введенные в Java 8, представляют собой
синтаксический сахар, который позволяет компактно и выразительно создавать
анонимные функции или реализации функциональных интерфейсов. Лямбдавыражения сокращают объем кода, делают его читабельным. В нашем случае
был использован for-each (рисунки 15, 16), но этот цикл можно записать еще
компактнее и удобнее. Используя метод forEach, который принимает
функциональный интерфейс Consumer, реализуем интерфейс Consumer,
используя лямбда выражение (рисунок 17).
Рисунок 17 – Фрагмент кода.
Итерация по списку происходит в for-each цикле
Ссылки на методы являются альтернативой лямбда-выражениям, когда
целью является просто вызов существующего метода, а не создание новой
анонимной функции. В данной работе целью является вызов метода println для
каждого элемента (рисунок 18). Получается очень компактно и удобно.
Рисунок 18 – Фрагмент кода.
Итерация по списку происходит в for-each цикле
В результате готовый код стал читабельнее и почти в два раза короче (рисунок
19).
Рисунок 19 – Готовый код
Был произведен расчет времени выполнения первого и второго кода с
помощью метода System.nanoTime (рисунок 20).
Рисунок 20 – Время выполнения 1 и 2 кода
Результаты исследования показали, что второй код не только меньше, но и
в 4 раза производительнее, чем первый. Исследование актуально для
разработчиков на Java любого уровня.
