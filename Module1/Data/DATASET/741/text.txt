Одними из ключевых элементов во многих веб-приложениях являются компоненты с авторизацией и регистрацией. Именно с них начинается процесс определения того, какие части интерфейса
видны пользователю, а какие нет.
Наиболее эффективный способ авторизации – использование JWT (JSON Web Token).
JWT представляет из себя обычную закодированную строку, которая состоит из трёх частей:
 заголовок;
 основные данные;
 сигнатура.
Заголовок обязательно должен хранить информацию об алгоритме шифрования, а необязательными полями являются тип токена и другие вспомогательные элементы. Вторая часть JWT токена –
это основные данные. Чаще всего ими является данные о пользователе, который проходит авторизацию. Почта, уникальный идентификатор, роли для определения прав доступа и другая информация
может быть включена во вторую часть. Но заголовок и основные данные хранятся в открытом виде и
раскодировать их может каждый желающий. Это не составит труда и поэтому хранить там какую-то
важную информацию, например пароли, точно не стоит. Но JWT предоставляет безопасность, которой
12 НОВОСТИ НАУКИ
II международная научно-практическая конференция | МЦНС «НАУКА И ПРОСВЕЩЕНИЕ»
является сигнатура. И для того, чтобы её получить нужен секретный ключ. А его знает только сервер.
Таким образом, заголовок и данные кодируются с помощью секретного ключа и на выходе образуется
сигнатура (рисунок 1).
Рис. 1. Структура JWT
Сигнатура нужна для того, чтобы убедиться, что токен не был подделан. То есть если не знать
секретный ключ, сигнатуру практически невозможно получить.
Используя данную технологию в веб-приложении, предстоит работать с двумя токенами: access и
refresh.
Каждый из них имеет свой срок жизни. Поэтому через определённое время он становится не валиден и умирает. Это делается для безопасности, так как если мошенник каким-то образом украл токен
пользователя, то он сможет пользоваться сервисом только пока жив этот токен. И для того, чтобы получить новый, совсем не обязательно снова авторизовываться. Существует токен доступа (access) и
другой, который его перезаписывает. Он называется refresh токеном. Access живёт около 15-30 минут.
Эта цифра может варьироваться, так всё зависит от того насколько секретная информация у сервиса,
но чем меньше эта цифра, тем безопаснее. Refresh токен живёт гораздо дольше, обычно от двух
недель до пары месяцев. И если в течение этих двух месяцев пользователь не посещал сервис, этот
токен умер, и ему придётся снова авторизоваться.
Таким образом, access используется для доступа к веб-приложению, а refresh для обновления
этого токена.
Когда пользователь приступает к авторизации, то данные, собранные из формы, отправляются
на сервер, где после начинается генерация access и refresh токенов, а после отправляются на клиентскую часть. Далее посылается запрос на получение данных о пользователе, и вся эта информация
сразу же сохраняется в глобальном хранилище.
У React есть одна очень важная проблема – это обмен данными, которые осуществляются с помощью пропсов. Это аргументы, которые компонент может принимать из вне. Но обмен ими всегда
происходит сверху вниз, то есть от родителя к дочернему элементу, и передача в обратном порядке
невозможна. Конечно, можно из родительского компонента в дочерний передать функцию обратного
вызова. И она будет ожидать на вход данные, которые отправит на верхний уровень. И такая вложенность может быть сколь угодно огромных масштабов, а доступ к определённой переменной нужен везде. И постоянно проводить настолько трудоёмкие манипуляции для передачи данных не является целесообразным. Для такой ситуации существует хук useContext. Хуки – это некоторые функции, которые
предоставляет React. Они всегда начинаются со слова use. При этом хуки можно использовать либо в
функциональных компонентах, либо в своих собственных хуках. То есть можно делать на основе стандартных React-хуков свои уникальные с различным функционалом. При этом их можно использовать
только на верхнем уровне вложенности компонента или собственного хука. Их нельзя вкладывать в
функции, условия или циклы.
Рассмотрим рисунок 2.
НОВОСТИ НАУКИ 13
II International scientific conference | www.naukaip.ru
Рис. 2. Обмен данными в React
Слева диаграмма потока данных, когда информация передаётся от родителя к дочернему компоненту, а также с помощью функций обратного вызова происходит всё в обратном порядке. А справа
показан оптимизированный подход, где context создаёт глобальное хранилище. И любой компонент
может обратиться к этому контейнеру с данными, избегая передачи от родителя к ребёнку.
Первым шагом в использовании оптимизированного подхода был создан сам context c названием
AuthContext, где добавляются значения и функции для хранения данных о пользователе и токенах (листинг 1).
export const AuthContext = createContext({ isLoaded: false,
 user: null, //Пользователь
 token: null, //Access токен
 refreshToken: null, //Refresh токен
 setUser: () => {},
 setToken: () => {},
 setRefreshToken: () => {},
 logOut: () => {},});
Лист. 1. Создание контекста
А следующим этапом добавляется собственный хук useAuth, который включает в себя
useContext, принимающий в качестве параметра ранее созданный AuthContext. И таким образом было
реализовано глобальное хранилище.
