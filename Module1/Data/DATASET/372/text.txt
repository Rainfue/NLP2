По мере того как программное обеспечение становится все более
модульным, растет потребность в защите веб-приложений. Криптография становится все более важна в современной разработке приложений
с многочисленными вариантами использования, будь то сквозное шифрование в приложении для обмена сообщениями, схема аутентификации для онлайн-банкинга или доказательство целостности важных
данных.
До недавнего времени в браузерах не было встроенных криптографических API, что привело к появлению большого количества библиотек JavaScript, реализующих криптографию для веб-приложений. Как
Информатика и компьютерные системы
54 54
бы хорошо ни были спроектированы и написаны эти библиотеки, программисты были вынуждены использовать JavaScript, который оказался
особенно неподходящим языком программирования для криптографических алгоритмов из-за своей высокоуровневой природы, отсутствия
64-битной целочисленной арифметики, доступа к аппаратным функциям и многопоточности [14, p. 10].
Сообщество Node.js рано осознало важность криптографии и уже
более 10 лет предоставляет различные криптографические функции с
помощью криптомодуля Node.js [5].
В 2017 г. Консорциум World Wide Web (W3C) опубликовал Web Cryptography API, что позволяет приложениям JavaScript в браузерах использовать общие криптографические функции без необходимости обращения к каким-либо сторонним библиотекам. Эти функции, независимо от того, предоставляются они через криптографический сервис
API или через криптомодуль Node.js, часто называют «криптографическими примитивами». Несмотря на то что эти механизмы хорошо зарекомендовали себя и считаются безопасными сами по себе, их легко использовать неправильно и, возможно, небезопасным образом [10].
Дизайн Web Crypto API
На момент написания статьи все популярные браузеры обеспечивают реализацию Web Crypto API для приложений JavaScript через полуглобальный криптообъект (англ. semi-global crypto object) [3]. Теперь
рассмотрим API и способы его использования.
Получение криптографически защищенных случайных данных
Первую примечательную особенность Web Crypto API составляет
crypto.getRandomValues, который в настоящее время является
единственным способом для веб-приложений получать криптографически безопасные случайные данные:
const twentyBytes = crypto.getRandomValues(new
Uint8Array(20));
console.log(twentyBytes);
Все остальные функции Web Crypto API доступны через объект
crypto.subtle. В отличие от crypto.getRandomValues, все функции crypto.subtle возвращают объекты Promise, как указано в спецификации языка ECMAScript 2015, что позволяет браузерам выполнять необходимые вычисления асинхронно в фоновом режиме вместо
блокировки цикла обработки событий JavaScript.
Общие интерфейсы для использования
криптографических алгоритмов
Web Crypto API предоставляет набор универсальных интерфейсов
для выполнения операций с использованием различных криптографических алгоритмов, которые идентифицируются стандартизированными и в основном говорящими сами за себя именами, такими как AES-CTR,
RSA-OAEP, SHA-256 и PBKDF2 [12].
М.Д. Былинский
55 55
Все операции принимают объект, идентифицирующий алгоритм и
опции, если это необходимо. Например, этот фрагмент кода генерирует
ключ AES, а затем шифрует сообщение с использованием режима сцепления блоков шифротекста (англ. Cipher Block Chaining mode (CBC)):
const key = await crypto.subtle.generateKey(
 // The algorithm is AES in CBC mode, with a key
length
 // of 256 bits.
 {
 name: 'AES-CBC',
 length: 256
 },
 // Allow extracting the key material (see below).
 true,
 // Restrict usage of this key to encryption.
 ['encrypt']
);
// AES-CBC requires a 128-bit initialization vector
(iv).
const iv = crypto.getRandomValues(new Uint8Array(16));
// This is the plaintext:
const encoder = new TextEncoder();
const message = encoder.encode('Hello world!');
// Finally, encrypt the plaintext, and obtain the
ciphertext.
const ciphertext = await crypto.subtle.encrypt(
 // The algorithm is still AES-CBC. In addition,
the
 // 128-bit initialization vector must be specified.
 {
 name: 'AES-CBC',
 iv
 },
 // The encryption key. This must be an AES-CBC key,
 // otherwise, this function will reject.
 key,
 // The plaintext to encrypt.
 message
);
Web Cryptography API использует экземпляры класса ArrayBuffer
для представления последовательности байтов, но большинство функций также принимают любой тип TypedArray в качестве входных данных [13]. Результатом crypto.subtle.encrypt будет ArrayBuffer,
и, вероятно, его необходимо преобразовать в другой тип данных или
формат для хранения или передачи зашифрованных данных.
Информатика и компьютерные системы
56 56
Шаблоны использования соответствуют лучшим практикам
в криптографии
В отличие от многих других криптографических библиотек, Web
Crypto API применяет некоторые шаблоны использования ключей, соответствующие известным передовым методам криптографии [15].
Ключи можно использовать и получать к ним доступ только через класс
CryptoKey, который накладывает определенные ограничения: материал ключа может быть извлечен из CryptoKey только в том случае,
если его свойство extractable было явно установлено в true во время
его создания.
Точно так же каждый CryptoKey имеет алгоритм (algorithm) и
атрибут использования (usages). Если ключ используется для операции (например, для создания цифровой подписи) в контексте алгоритма (например, RSASSA-PSS), операция завершается ошибкой, если алгоритм (algorithm) ключа не равен запрошенному алгоритму или если использование (usages) свойства не содержит запрошенное имя
операции [8].
Эти ключевые свойства сохраняются при импорте и экспорте ключей в формате JSON Web Key (JWK), но не в любом другом поддерживаемом формате. JWK представляет собой JSON-представление ключевого материала и поэтому является хорошим выбором для хранения или
передачи данных в среде, которая традиционно имеет очень ограниченную поддержку двоичных данных [11, p. 9].
Неизменяемые объекты WebCrypto без состояния
Хороший аспект дизайна API заключается в том, что там, где другие
библиотеки часто требуют, чтобы объекты проходили сложные жизненные циклы, все объекты WebCrypto не имеют состояния (англ. stateless) и неизменяемы (англ. immutable), что делает невозможным случайное использование ключей или алгоритмов в недопустимом или неожиданном состоянии.
Ограничения Web Crypto API
Одним из текущих ограничений Web Crypto API является отсутствие поддержки любой потоковой передачи. Одновременная обработка больших объемов данных обычно относительно неэффективна, поэтому Node.js предоставляет потоковые интерфейсы для многих криптографических функций, включая симметричное шифрование и дешифрование, хеширование, создание цифровой подписи и ее проверку.
Поддержка браузерами криптографических API различается, и хотя все распространенные браузеры реализуют API, нет гарантии, что
конкретный алгоритм поддерживается во всех браузерах [4]. Если вебприложение требует определенного алгоритма, и предполагается, что
М.Д. Былинский
57 57
оно будет работать в браузерах, которые могут его не поддерживать, может потребоваться динамическое переключение на реализацию JavaScript
(«polyfill»).
Некоторые аспекты API неясны в рекомендации W3C, и поведение
браузеров отличается [9, p. 129]. Например, Firefox 73, в отличие от
Google Chrome 80, позволяет разработчикам создавать ключи, которые
нельзя ни извлечь, ни использовать, что означает, что их атрибуту extractable присвоено значение false, а атрибуту usages — пустой
массив. Точно также Web Crypto API не требует, чтобы браузеры выдавали разумные сообщения об ошибках, и многие браузеры этого не делают, что приводит к разочарованию при отладке программного кода,
использующего API.
В рекомендации Web Crypto API также предлагаются нестандартные функции, такие как параметр длины для AES в режиме счетчика
(англ. counter mode), который позволяет пользователям ограничивать
количество битов вектора инициализации, используемых в качестве
счетчика. Эти функции доступны не во всех реализациях, а некоторые
реализации могут игнорировать такие опции, что затрудняет обнаружение функций.
Совместимость с криптомодулем Node.js
Официальные дистрибутивы Node.js поддерживают все функции
Web Crypto API, но модуль шифрования Node.js предоставляет другой
API, а также другие функции и классы. Функции Web Crypto API, как
правило, более общие. Например, все симметричное и асимметричное
шифрование обрабатывается через crypto.subtle.encrypt, тогда как
Node.js предоставляет отдельные функции crypto.createCipheriv,
crypto.publicEncrypt и crypto.privateEncrypt, в зависимости
от того, какой тип шифрования необходимо выполнить.
В большинстве случаев обмен данными между WebCrypto и Node.js
crypto API относительно прост, но есть некоторые исключения. В некоторых случаях Web Crypto API представляет данные иначе, чем Node.js.
Например, аутентифицированное симметричное шифрование, такое
как AES-GCM, создает зашифрованный текст C и тег аутентификации T
как отдельные последовательности в Node.js, но как единую конкатенированную последовательность C | Т в WebCrypto. И поскольку T имеет фиксированный размер, преобразование между отдельными значениями и конкатенированной последовательностью легко реализовать в
JavaScript.
Обмен ключами между Web Crypto API и Node.js в настоящее время
ограничен отсутствием поддержки формата веб-ключа JSON (jwk) в
Node.js [7]. Однако другие форматы кодирования ключей, используемые Web Crypto API (например, spki, pkcs8 и raw), обычно хорошо
поддерживаются и предлагают подходящую замену.
Команда Node.js недавно добавила в криптомодуль Node.js различные функции для обеспечения лучшей совместимости, например, под-
Информатика и компьютерные системы
58 58
держку подписей RSASSA-PSS, настраиваемые хэш-функции для RSAOAEP, функции для создания пары асимметричных ключей и преобразования между различными форматами ключей и подписей. Благодаря
этим дополнениям к Node.js, веб-приложения могут рассчитывать на
превосходную совместимость между Node.js и современными веб-браузерами.
Прототип WebCrypto для Node.js
Существует небольшое количество сторонних реализаций Web
Crypto API для Node.js, и команда Node.js находится в процессе оценки
потенциала Web Crypto API для приложений Node.js, включая реализацию прототипа, написанного на JavaScript:
Асинхронность. Спецификация WebCrypto требует, чтобы почти все
операции выполнялись асинхронно, однако Node.js реализует очень мало операций асинхронно [6]. Обычно это не проблема, поскольку:
1) большинство криптографических функций невероятно быстры по
сравнению с оверхедом (англ. overhead), который неразрывно связан с
асинхронностью, 2) так как Node.js реализует большинство криптографических функций через эффективные потоковые интерфейсы.
WebCrypto не имеет потоковых интерфейсов, а только одноразовые
API. Таким образом, шифрование, хэширование, подпись или проверка
больших объемов данных в WebCrypto затруднены без базовых асинхронных API.
Структура. Основной экспорт реализован в lib/index.js и представляет интерфейс crypto, как определено в разделе 10 спецификации WebCrypto. Он содержит:
1) subtle атрибут реализован в lib/subtle.js, включая все методы, описанные в разделе 14.3 спецификации WebCrypto. Эти методы
обычно делегируют работу одной или нескольким криптографическим
операциям, перечисленным в разделе 18.2.2 и реализованным в lib/
algorithms/;
2) функция getRandomValues реализована в lib/random.js.
Тесты. Каталог test содержит небольшое количество модульных
тестов. Все эти тесты необходимо проходить после каждого коммита.
Можно запускать модульные тесты с помощью npm test.
Отчет о покрытии можно создать с помощью команды npm
runcover.
Подмножество тестов веб-платформы также можно использовать
для тестирования. Целесообразно инициализировать подмодуль
test/wpt/wpt, чтобы использовать их. Можно запустить WPT, используя npm run wpt. Предлагаемые изменения не обязательно должны
проходить все WPT, но они не должны нарушать тесты, которые прошли без изменений.
Линтинг. Этот репозиторий использует ESLint. Необходимо использовать npm run lint для проверки кода.
М.Д. Былинский
59 59
Использование Web Crypto API в Node.js
Одним из преимуществ использования Web Crypto API является
возможность повторного использования одного и того же кода для
браузерных приложений и приложений Node.js [2]. Однако некоторые
характеристики веб-стандарта потенциально лучше подходят для браузеров, чем для Node.js, включая отсутствие поддержки потоковой передачи. Использование объектов Promise имеет смысл в современном
JavaScript, но может привести к значительным накладным расходам на
сервере при выполнении множества кратковременных криптографических операций, которые могут выполняться так же быстро, как один вызов
функции в криптомодуле Node.js [1]. Также кажется неудобным то, что
Web Crypto API работает с экземплярами ArrayBuffer, тогда как приложения Node.js в основном работают с экземплярами класса Buffer.
Ближайшая цель команды Node.js — обеспечить совместимость
между Web Crypto API и существующим криптомодулем Node.js. Разумеется, по мере приближения к цели возникают определенные трудности, тем не менее пока можно отметить действительно основательный
подход. Криптография, JavaScript и Node.js — быстро меняющиеся технологии, и такие стандарты, как Web Crypto API, должны будут соответствующим образом адаптироваться, как и их реализации. 