На платформе Node.js создаются разнообразные службы и приложения. Серверы
любого назначения, распределенные системы, мультимедийные и коммуникационные
сервисы. Написать все это совсем не сложно. Если знать основы
Честно говоря, эта статья цикла будет слегка занудной.
Но тем не менее убедительно прошу потратить на нее время; после освоения изложенного ниже материала практически все невероятные возможности платформы Node.js
будут вам доступны. Иначе – нет. В самом деле без изучения
базовых компонентов системы не обойтись. Да и... ладно,
насчет занудности я преувеличиваю.
Давайте рассмотрим, что собой представляет Node
как «Software system». Из примеров, представленных в предыдущей статье [1], можно сделать вывод о модульном
характере ее архитектуры, и он будет совершенно верен.
Даже в простом движке плоского сайта мы использовали
почти десяток модулей, каждый из которых отвечает за чтото свое.
Это нормальный принцип построения Node-приложений.
Но, разумеется, этим и многим другим модулям просто
не с чем было бы работать, если бы не основа системы – ядро Node.js, содержащее объекты и методы, доступные всем модулям в глобальном пространстве имен. Именно
с этого мы и начнем изучение Node, попутно освоив базовые понятия и элементы системы.
Как все работает? event loop в Node.js
В основе Node.js лежит библиотека libev, реализующая цикл
событий (event loop). Libev – это написанная на C библиотека событийно-ориентированной обработки данных, предназначена для упрощения асинхронного неблокирующего
ввода/вывода.
При каждой итерации цикла происходят следующие события (причем именно в таком порядке):
> Выполняются функции, установленные на предыдущей итерации с помощью особого метода – process.
nextTick().
> Обрабатываются события libev, в том числе события
таймеров.
> Выполняется опрос libeio (библиотеки для создания
пула потоков – thread pool ) для завершения операций
ввода/вывода и выполнения установленных для них
коллбеков.
Если ни одно из вышеперечисленных действий не потребовалось (то есть все очереди, таймеры и т.д. оказались
пусты), Node.js завершает работу.
Глобальные объекты (Globals)
С Globals, т.е. объектами, методами, доступными из любого
метода, любого модуля мы уже успели столкнуться. Это,
например, метод require или объект console. Давайте теперь разберем глобальные объекты и методы Node.js подробнее.
Global
Самый главный в иерархии глобальных объектов так и называется – Global.
Если у вас есть опыт программирования на JavaScript,
то должны знать одну особенность его реализации в браузере. При инициализации переменной на верхнем уровне
вложенности ее область видимости автоматически становится глобальной.
В Node.js переменная, объявленная в любом месте модуля, так и будет определена только в этом модуле (и это замечательно!), чтобы она стала глобальной, необходимо объявить ее как свойство объекта Global:
> global.foo = 2
2
> console.log(global)
{ ArrayBuffer: [Function: ArrayBuffer],
 Int8Array: { [Function: Int8Array] BYTES_PER_ELEMENT: 1 },
 Uint8Array: { [Function: Uint8Array] BYTES_PER_ELEMENT: 1 },
…..........................................................
 registerExtension: [Function],
 cache: {} },
 _: 2,
 foo: 2 }
Надо сказать, что команда consolо.log(global), всегда позволяет получить массу полезной и интересной информации.
Фактический Global – это аналог объекта window в DOMмодели браузера.
Здесь все понятно – этот объект используется для стандартного вывода и вывода ошибок (stdout и stderr ). Основной
его метод console.log() просто выводит заданную строку
(или объект, приведенный к строке) на стандартный вывод.
console.log() может принимать два аргумента, аналогично
Си функции printf( ):
> bar = 7
7
> console.log('Price: %d', bar);
Price: 7
Для stderr (стандартного потока вывода ошибок) существует метод console.error(), в остальном полностью аналогичный console.log(). Еще два метода console – console.time()
и console.timeEnd() – позволяют отслеживать время исполнения программы. Первый из них устанавливает (запоминает) текущее время, а второй завершает отсчет времени
и выводит результат:
console.time('items');
for (var i = 0; i < 1000000000; i++) {
 // что-нибудь делаем
}
console.timeEnd('1000000000-items');
1000000000-items: 1492ms
Для отладки также полезен метод console.trace(), выводящий в консоль стек вызовов для текущей инструкции:
for (var i = 0; i < 100; i++) {
 console.trace()
}
Trace
 at Object.<anonymous> (C:\Users\Geol\time.js:5:10)
 at Module._compile (module.js:456:26)
 at Object.Module._extensions..js (module.js:474:10)
 at Module.load (module.js:356:32)
 at Function.Module._load (module.js:312:12)
 at Function.Module.runMain (module.js:497:10)
 at startup (node.js:119:16)
 at node.js:901:3
Trace
 at Object.<anonymous> (C:\Users\Geol\time.js:5:10)
 at Module._compile (module.js:456:26)
 at Object.Module._extensions..js (module.js:474:10)
 at Module.load (module.js:356:32)
 at Function.Module._load (module.js:312:12)
 at Function.Module.runMain (module.js:497:10)
 at startup (node.js:119:16)
 at node.js:901:3
…........................................
require()
Метод require, служащий для подключения модулей, на самом деле не является глобальным – он локален для каждого
из них. Это же относится к методу require.resolve(), возвращающему имя файла, содержащего модуль, и свойствам
require.cache и require.paths. Первое из них отвечает за кэширование модулей, а второе – за пути их загрузки.
Также к Global относят свойства, на самом деле также
являющиеся локальными:
module – ссылка на текущий модуль;
exports – объект, является общим для всех экземпляров
текущего модуля, доступным при использовании require().
Exports;
__filename – имя исполняемого скрипта (абсолютный
путь);
__dirname – имя директории исполняемого скрипта.
Кроме того, в секцию Globals входят еще три важных элемента, о которых поговорим ниже:
Process – объект процесса. Большая часть данных процесса находится именно здесь.
Class: Buffer – объект используется для операций с бинарными данными.
Таймеры – группа методов для контроля времени исполнения.
Процессы
Каждое Node.js-приложение – это экземпляр объекта
Process, и он наследует его свойства.
Это свойства и метода, несущие информацию о приложении и контексте его исполнения. Пример работы некоторых из них (назначение очевидно из их названий):
console.log(process.execPath);
console.log(process.version);
console.log(process.platform);
console.log(process.arch);
console.log(process.title);
console.log(process.pid);
Результат может быть, например, таким:
C:\Users\Geol>node process.js
C:\Program Files\nodejs\node.exe
v0.10.7
win32
x64
Command Prompt - node process.js
5896
Свойства process.moduleLoadList показывают информацию о загруженных модулях, а process.argv содержит массив аргументов командной строки:
process.argv.forEach(function(val, index, array) {
 console.log(index + ' - ' + val);
});
Запустим этот сценарий с несколькими аргументами:
C:\Users\Geol>node process.js foo bar 1
0 - node
1 - C:\Users\Geol\process.js
2 - foo
3 - bar
4 – 1
Тут можно понять, что первым аргументом считается имя
исполняемого приложения, вторым – сам сценарий (точнее,
файл, его содержащий).
Метод process.env возвращает объект, хранящий пользовательское окружение процесса, и практически незаменим
при отладке приложений. Ниже показана часть вывода команды console.log(process.env):
Разработка
системный администратор сентябрь 2013 61
веб-технологии
{ ALLUSERSPROFILE: 'C:\\ProgramData',
 APPDATA: 'C:\\Users\\Geol\\AppData\\Roaming',
 'asl.log': 'Destination=file',
 CommonProgramFiles: 'C:\\Program Files\\Common Files',
 COMPUTERNAME: 'GEOL-PC',
 ComSpec: 'C:\\Windows\\system32\\cmd.exe',
 FP_NO_HOST_CHECK: 'NO',
 HOMEDRIVE: 'C:',
 HOMEPATH: '\\Users\\Geol',
 …...
 PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;↵
.WSH;.MSC',
 PROCESSOR_ARCHITECTURE: 'AMD64',
 PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 37
 Stepping 5, GenuineIntel',
 PROCESSOR_LEVEL: '6',
 PROCESSOR_REVISION: '2505',
…....
 PUBLIC: 'C:\\Users\\Public',
 SESSIONNAME: 'Console',
 SystemDrive: 'C:',
 SystemRoot: 'C:\\Windows',
 USERDOMAIN: 'Geol-PC',
 USERNAME: 'Geol',
 USERPROFILE: 'C:\\Users\\Geol',
 VBOX_INSTALL_PATH: 'C:\\Program Files\\Oracle\\VirtualBox\\',
 windir: 'C:\\Windows' }
Команда process.exit() завершает процесс с указанным
в качестве аргумента кодом (по умолчанию со стандартным
успешным кодом 0). Чтобы выйти с ошибкой, следует выполнить process.exit(1).
process.on('exit', function () {
setTimeout(function() {
 // Этот код никогда не запустится!
 console.log('This will not run');
 },0);
 console.log('Exit.');
});
У объекта Process, как и у всех порядочных JavaScriptобъектов, есть свои события, с которыми можно связать необходимые обработчики. Нас сейчас интересуют события, специфичные для него, прежде всего
так называемые сигнальные (Signal Events), которые генерируются при получении процессом сигнала (собственно
POSIX-функция sigaction). Сигналы могут быть стандартные,
POSIX-вые – SIGINT, SIGUSR1, SIGTSTP и др. Ниже приведен
пример кода, при запуске которого функция обратного вызова будет ждать сигнала, соответствующего нажатию Contr
+ C на клавиатуре:
process.stdin.resume();
process.on('SIGTSTP', function() {
 console.log('Interrupted');
 process.exit(1);
});
Вызов метода process.stdin.resume() тут нужен для начала
чтения из стандартного потока ввода.
Еще один пример:
process.on('SIGHUP', function() {
 console.log('Got a SIGHUP');
});
setInterval(function() {
 console.log('Running');
}, 10000);
console.log('PID:', process.pid);
После запуска этого кода в консоли мы увидим следующую картину:
PID: 5772
Running
Running
Running
Running
Running
Running
Running
Running
Теперь в другой консоли, зная PID запущенного процесса, можно послать требуемый сигнал:
Разработка
62 сентябрь 2013 системный администратор
веб-технологии
kill -s SIGHUP 5772
Результат:
Got a SIGHUP
Событие 'exit', как нетрудно догадаться, происходит
при завершении работы Node.js-сценария, а точнее, при выходе из цикла Event loop:
process.stdin.resume();
process.on('SIGINT', function() {
 console.log('Got a SIGINT!');
 process.exit(1);
});
Еще один информативный метод, process.memoryUsage(),
возвращает объект, описывающий потребление памяти
процессом Node (в байтах):
console.log(process.memoryUsage());
process.nextTick(function () {
 console.log('Test');
});
console.log(process.memoryUsage());
Вывод:
C:\Users\Geol>node process.js
{ rss: 11096064, heapTotal: 4083456, heapUsed: 2149792 }
{ rss: 11526144, heapTotal: 5115392, heapUsed: 2493656 }
Test
Тут следует пояснить, что heapTotal и heapUsed характеризуют потребление памяти JavaScript движком V8.
Как вы могли заметить, в этом примере мы использовали еще один метод объекта Process – process.nextTick();
он напрямую отсылает нас к циклу событий (event loop),
с описания которого мы начали этот раздел. NextTick() назначает функцию, служащую ему аргументом, к исполнению
при следующей итерации цикла событий. Это такой своеобразный event handler, специфичный для Node.js, который,
правда, в этом примере служит всего лишь элегантной заменой setTimeout(). Работу NextTick() руководство поясняет
на более простом примере:
process.nextTick(function() {
 console.log('nextTick callback');
});
Метод process.kill(), аргументами которого служат идентификатор процесса и команда, делает то же, что и одноименная команда операционной системы, то есть посылает
сигнал процессу (как в случае posix kill, это не обязательно
сигнал завершения).
Понятие буфера
В любой системе, претендующей на роль серверной платформы, в веб-среде необходимы средства для полноценной
работы с потоками двоичных данных – одним plane текстом
сыт не будешь. В класcическом JavaScript подобные средства отсутствовали (если не считать недавно появившихся
Типов File API, ArrayBuffer, относящихся не к самому языку,
а к объектной модели браузера). В Node.js для решения подобных задач существует класс Buffer. Бинарные данные
хранятся в экземплярах этого класса, с ним ассоциирована
область памяти, выделенная вне стандартной кучи V8.
Еще одна проблема, которую решает данный объект,
является частным случаем первой. Я имею в виду работу
со строками unicode.
При преобразовании между буферами и строками
JavaScript требуется явно указывать метод кодирования
символов. Node поддерживает следующие кодировки
для строк:
'ascii' – только для 7-битных ASCII-строк. Этот метод кодирования очень быстрый, он сбрасывает старший бит
символа.
'utf8' – unicode-символы UTF-8.
'binary' – хранит двоичные данные в строке, используя
младшие 8 бит каждого символа. Это кодирование не будет поддерживаться в будущих версиях.
'base64' – строка, закодированная в системе Base64.
'hex' – кодирует каждый байт как два шестнадцатиричных
символа.
Работа с буфером происходит следующим образом:
buf = new Buffer(256, 'utf8');
text = '\u00bd + \u00bc = \u0D75';
len = buf.write(text , 0, text.length);
console.log(len + " bytes: " + buf.toString('utf8', 0, len));
Этот (чуть измененный) пример из руководства выводит
в консоль следующую строку (при наличии соответствующей кодировки):
C:\Users\Geol\node>node ts1.js
13 bytes: 1/2 + 1/4 =
Конструктор объекта получает в качестве аргумента желаемый размер буфера в байтах (его потом невозможно изменить). Тут же вторым аргументом указываем кодировку.
Можно этого не делать: требуемый utf8 – значение по умолчанию.
В данном примере мы использовали метод buffer.write,
помещающий данные в буфер. Он возвращает количество байт. Аргументами его служат (кроме самой строки) начальная и конечная позиции записи данных в пространство
буфера. Обе они не обязательны. Важная особенность,
призванная немного пожалеть психику разработчиков, – несмотря на то что запись данных прекращается при превышении размера буфера, символы юникода не будут записаны «частично», по первому байту, или целиком, или никак.
Думаю, что Perl, php да и Си-разработчики, могут по достоинству оценить эту мелочь.
Метод buffer.toString(), как несложно догадаться, превращает содержимое буфера в вид строки. При необходимости
(см. первый аргумент в примере) может и перекодировать.
Для полного счастья программистов предусмотрен еще метод buffer.toJSON():
buf = new Buffer('test');
console.log(buf.toJSON());
[ 116, 101, 115, 116 ]
Разработка
системный администратор сентябрь 2013 63
веб-технологии
Метод buffer.length, возвращающий размер данных в буфере, имеет особенность – общий объем зарезервированного пространства под данные может не совпадать с объемом самих данных.
Еще один способ задания буфера – непосредственная
передача конструктору массива байтов (то есть восьмибитных данных):
buf = new Buffer([01,02,03,04,05]);
console.log(buf);
console.log(buf[4]);
Вывод:
<Buffer 01 02 03 04 05>
5
В последней строчке этого примера мы обращаемся к содержимому буфера по индексу – собственно, это основной
прием работы с данным объектом.
Что еще можно творить с буфером? Например, копировать один в другой, задав границы областей вставки и замещения:
buffer1 = new Buffer(24);
buffer2 = new Buffer(16 );
for (var i = 0 ; i < 24 ; i +=4) {
 buffer1[i] = 78;
 buffer1[i+1] = 111;
 buffer1[i+2] = 100;
 buffer1[i+3] = 101;
}
for (var i = 0 ; i < 16 ; i++) {
 buffer2[i] = 42; // ASCII *
}
buffer1.copy(buffer2, 6, 16, 20);
console.log(buffer2.toString('ascii'));
Вывод:
C:\Users\Geol\node>node ts1.js
******Node******
Метод buffer.slice() возвращает новый буфер, представляющий собой срез старого. При этом надо понимать,
что вновь сознанный объект указывает на ту же область памяти, что и предыдущий, соответственно любые изменения
нового буфера коснутся и источника:
var buffer2 = buffer1.slice(0, 3);
console.log(buffer2.toString('ascii', 0, buffer2.length));
buffer2[0] = 33;
console.log(buffer1.toString('ascii', 0, buffer1.length));
Вывод:
***
!*********
[TODO SlowBuffer]
Таймеры
Таймеры Node.js представлены несколькими жизненно необходимыми глобальными функциями, хорошо знакомыми
по классическому JavaScript. Прежде всего это setTimeout(),
позволяющая выполнить переданный ей в качестве аргумента код через заданное количество миллисекунд. Функция возвращает ID тайм-аута.
clearTimeout() обнуляет счетчики по заданному идентификатору. Работу этих двух функций можно продемонстрировать на простом рекурсивном примере:
var tid;
function toConsole(n) {
 console.log(n);
tid = setTimeout(toConsole, 1000, n+1);
if(n > 5){
 clearTimeout(tid);
}
}
toConsole(0);
Вывод:
C:\Users\Geol\node>node newNode1.js
0
1
2
3
4
5
6
Обратите внимание на то, что все дополнительные аргументы setTimeout превращаются в аргументы функции обратного вызова. Обстоятельство, что в консоль проникла
цифра 6, объясняется тем, что таймер успевает отработать
перед уничтожением.
Впрочем, аналогичная задача решается без всякой рекурсии двумя другими таймер-функциями – setInterval()
и clearInterval(), устанавливающими и сбрасывающими
(соответственно) так называемые интервальные таймеры,
то есть срабатывающие периодически, через заданный период времени:
var tid;
function toConsole() {
 console.log(n);
n++;
if(n > 5){
 clearInterval(tid);
}
}
var n = 0;
tid = setInterval(toConsole, 1000);
***
И это все! После получения вышеизложенных сведений (соглашусь, местами нудноватых), мы можем творить с Node.js
практически все! Не верите? Напрасно. То, что сейчас написано и реализовано для Node, – это модули, созданные
на данной основе.
Но! Работа с Node.js практически невозможна
без ее продвинутой событийной модели, модуля events
и класса EventEmitter. Именно о них мы и поговорим в следующий раз. EOF