В настоящее время проблема применение норм, весов и мер близости в качестве 
метода оптимизации поисковых запросов не теряет своей актуальности. Это обусловлено 
тем, что с ростом объема данных, а также ростом сложности структуры этих данных, 
современные системы управления базами данных (СУБД) все больше нуждаются в повышении производительности для удовлетворения потребностей программных комплексов, в 
которые они включены [1, 2].
Современные сервисы зачастую сталкиваются с проблемами чрезвычайной нагрузки 
за счет следующих факторов:
• необходимость обработки большого потока пользователей и как следствие необходимость обработки большого количества запросов;
• необходимость работы со сложными структурами данных, на обработку которых 
тратится большое количество вычислительной мощности;
• необходимость поддерживать целостность и полноту данных, что приводит к 
неизбежным задержкам в их обработке.
Сейчас подобные проблемы решаются, как правило, экстенсивными способами. 
Например, увеличением процессорной мощности или увеличением количества рабочих 
станций с СУБД. Однако, данные способы являются неэффективными с точки зрения затрат, 
а также имеют строгие ограничения в своем применении. Так увеличение числа кластеров 
вычисления в какой-то момент неизбежно приведет к перегрузке шины обмена данными. 
Для того чтобы избежать подобных проблем необходимо прибегать к интенсивным способам 
повышения производительности. Например, используя более подходящие архитектуры, 
применяя алгоритмы оптимизации запросов или правильное распределение данных и 
процессорной нагрузки.
Остановимся подробнее на алгоритме поиска на основе веса и его применении для 
распределения данных. Предлагаемый метод направлен на оптимизацию поисковых запросов, а также для проверки наличия ключей. В нем для оптимизации запросов поиска того или 
иного элемента, причем как в смысле пользовательского запроса, так и внутрисистемного 
обращения к базе данных предлагается использовать понятие веса элемента.
Весом элемента назовем сумму долей заполнений пространства отведенного под тип 
каждого столбца. То есть если в таблице имеется четыре столбца, под каждый из которых отведено 64 бита, то максимальным весом можно считать 256 битов. Для разных типов 
предполагается «нормировать» значения памяти отведенное под данный тип. Это необходимо чтобы «большие» типы не перетягивали на себя приоритет при поиске. Значения веса 
выгодно хранить для строк по столбцам, чтобы их не пересчитывать при каждом поиске. Для 
нестандартных табличных сущностей, например, для изображений можно заменить столбцы 
на перцептивный хеш. Он представляет собой последовательность фиксированной длины, 
где каждый бит отражает часть изображения. В этом случае весом изображения будет сумма 
единиц такого хеша. В общем случае это применимо к любым типам, если выразить 
значения их столбцов в вектор битовых значений. При этом с точки зрения производительности выгоднее ориентироваться на хеши или на «заполнение» типа столбца, так как 
иная схема близка к перебору. Таким образом, при запросе применяется сверка весов 
поискового образа и записей в имеющейся таблице. Показано [3] что элементы, веса которых 
различаются, далеки друг от друга не менее чем на то же значение, что и разница их весов по 
выбранной метрике. Тогда на основании такого принципа можно заведомо отбросить 
большое количество «отдаленных» записей, тем самым сократив поиск до меньшего числа, 
потенциально «похожих» вариантов. Аналогичным образом можно ориентироваться при 
поиске не идентичных, а похожих сущностей.
Поскольку вес является величиной достаточно постоянной, так как меняется только 
при явном логическом изменении данных, на его основе можно распределять таблицы для 
осуществления как поисковых, так и других более сложных операций. Понятие веса подобно 
понятию нормы на пространстве строк таблицы. Оно порождает отношение эквивалентности, а значит, разбивает множество записей на непересекающиеся классы, таким образом, 
образуя фактор-множество. Основываясь на классах фактор-множества можно построить 
достаточно эффективное разбиение, основываясь на горизонтальном равномерном распределении [4]. При этом классы будут иметь достаточно равномерное распределение, что 
позволит производить поисковые запросы более эффективно. Кроме того такое разбиение 
поможет совершать операции типа Join за более короткое время, так как операции сверки 
ключей также будут использовать данный алгоритм. Это не открывает возможности избегать 
перебалансировки классов со временем, ведь база пополняется, и классы начинают менять 
свою мощность. Однако как было замечено на примере изображений, в общем случае 
большие потоки данных достаточно равномерны и потому перебалансировка требуется не 
так часто, тем более что ее осуществление не является сложным.
Итак, такой подход позволяет не только эффективно находить равные или схожие 
последовательности ключей для операций поиска и сравнения, но и выстроить распределенную систему для оптимизации других более сложных операций, например, таких как Join. 
Применение подобного подхода, является хорошей мерой по оптимизации своих сервисов в 
тех случаях, когда данных становится много. Особенно метод будет эффективен в случаях, 
когда нет возможности пользоваться индексами, поскольку подобное решение позволяет 
отбрасывать заведомо неподходящие варианты, как и в случае с индексами, за счет работы с 
метаданными таблицы, вне зависимости от самих данных. Причем в отличие от индексов 
подход не имеет большой дополнительной вычислительной нагрузки, в связи с этим 
возможно его применение со всеми другими подходами. Таким образом, удается значительно минимизировать количество операций, уходящих на запрос, что приводит к немалому 
росту производительности системы. За счёт использования метаданных можно существенно 
повысить производительность выполнения цепочек сложных операций [5]. А использование 
весов структур позволяет сократить время сравнения ключей. Таким образом, на основе 
вышеизложенного подхода работы с метаданными на основе веса можно существенно 
снизить нагрузку на сервисные архитектуры высоконагруженных приложений.