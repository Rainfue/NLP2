Интернет прошел большой путь для поддержки полнодуплексной (или двусторонней) связи между клиентом и сервером. Это главная цель протокола WebSocket: обеспечить постоянную связь в режиме реального времени между клиентом и сервером через одно сокетное соединение TCP. Протокол
WebSocket имеет только две программы: открыть рукопожатие и помочь в передаче данных. Как только
сервер и клиент получат свои рукопожатия, они смогут отправлять данные друг другу с меньшими затратами по желанию.
Связь WebSocket осуществляется через один сокет TCP с использованием протокола WS (порт
80) или WSS (порт 443). На момент написания статьи почти каждый браузер, кроме Opera Mini, обеспечивает поддержку WebSockets.
Исторически сложилось, что для создания веб-приложений, которым требовались данные в реальном времени (например, игровые или чат-приложения), требовалось «злоупотребление» протоколом HTTP для установления двунаправленной передачи данных. Для достижения возможностей в реальном времени использовалось несколько методов, но ни один из них не был столь же эффективен,
как WebSockets. HTTP- polling (HTTP-опрос), HTTP streaming (потоковая передача), Comet, SSE - все
они имели свои недостатки.
Самая первая попытка решить проблему состояла в регулярном опросе сервера. Жизненный
цикл длинного HTTP-опроса выглядит следующим образом:
1. Клиент отправляет запрос и продолжает ждать ответа.
2. Сервер откладывает свой ответ до тех пор, пока не произойдет изменение, обновление или
тайм-аут. Запрос оставался «зависшим» до тех пор, пока серверу не удалось что-то вернуть клиенту.
3. Когда на стороне сервера происходят какие-либо изменения или обновления, он отправляет
ответ клиенту.
4. Клиент отправляет новый длинный запрос на опрос, чтобы прослушать следующий набор
изменений.
В длинных опросах было много лазеек такие как: заголовки, задержка, время ожидания, кэширо-
140 НАУКА И ИННОВАЦИИ В XXI ВЕКЕ
XIII международная научно-практическая конференция | МЦНС «НАУКА И ПРОСВЕЩЕНИЕ»
вание и т.д.
Если же говорить о методе HTTP streaming, то можно сказать, что этот механизм избавляет от
сетевых задержек, поскольку первоначальный запрос остаётся открытым бесконечно долго. Запрос
никогда не прекращается, даже после того, как сервер отправит данные. Первые три метода жизненного цикла HTTP streaming такие же, как и у HTTP- polling. Однако, когда ответ отправляется обратно клиенту, запрос никогда не прекращается; сервер поддерживает соединение открытым и отправляет новые обновления всякий раз, когда происходит изменение.
SSE (Server-sent events - события, посылаемые сервером) - представляет собой технологию отправки уведомлений от сервера к веб-браузеру в виде DOM-событий. С SSE сервер передает данные
клиенту, приложение для чата или игр не может полностью полагаться на SSE. Идеальным вариантом
использования для SSE был бы, например, новостной ленты Facebook: всякий раз, когда появляются
новые сообщения, сервер отправляет их на ленту новостей. SSE отправляется по-традиционному
HTTP и имеет ограничения на количество открытых соединений. Эти методы были не просто неэффективными, а код, который писался при помощи данных методов занял бы очень много времени.
WebSockets предназначен для замены существующих технологий двунаправленной связи. Существующие методы, описанные выше, являются ни надежными, ни эффективными, когда речь идет о полнодуплексной связи в реальном времени. WebSockets похож на SSE, но при возвращает сообщения от
клиента на сервер. Ограничения на подключение больше не являются проблемой, поскольку данные обслуживаются через одно соединение через сокет TCP. Далее в статье будут описаны примеры как работает WebSockets на сервере Node.js к которому подключен клиент, созданный с использованием React.js.
Для создания создание рукопожатия на уровне сервера можно использовать один порт для выделения HTTP-сервера и сервера WebSocket. На рис. 1 показано создание простого HTTP-сервера. Как
только он будет создан, привязывается сервер WebSocket к порту HTTP.
Рис. 1. Создание рукопожатия на уровне сервера
Как только сервер WebSocket создан, необходимо принять рукопожатие при получении запроса
от клиента. В коде ниже все подключенные клиенты поддерживаются как объект с уникальным идентификатором пользователя при получении их запроса от браузера см. рис. 2.
Рис. 2. Принятие рукопожатие при получении запроса от клиента
При отправке обычного HTTP-запроса на установление соединения клиент отправляет в заголовки
запроса Sec-WebSocket-Key. Сервер кодирует и хэширует это значение и добавляет предопределенный
НАУКА И ИННОВАЦИИ В XXI ВЕКЕ 141
XIII International scientific conference | www.naukaip.ru
GUID (Globally Unique Identifier). Это повторяет сгенерированное значение в Sec-WebSocket-Accept на
отправленном сервером рукопожатии. Как только запрос принят на сервере (после необходимых проверок), рукопожатие выполняется со статус кодом 101. Если в браузере что-то, кроме статуса кода 101, обновление WebSocket завершилось неудачно, и будет соблюдена нормальная семантика HTTP. Поле заголовка Sec-WebSocket-Accept указывает, готов ли сервер принять соединение или нет. Кроме того, если
в ответе отсутствует Upgrade поле заголовка или Upgrade не равно websocket, это означает, что соединение WebSocket не удалось. Успешное серверное рукопожатие выглядит так рис. 3:
Рис. 3. Успешное рукопожатие с сервером
Для создания рукопожатия на уровне клиента используют тот же пакет WebSocket, который был
используем на сервере. Чтобы установить соединение с сервером (API WebSocket в Web IDL стандартизируется W3C). Как только запрос будет принят сервером, можно увидеть WebSocket Client
Connected в консоли браузера. Вот начальный каркас для создания соединения с сервером рис.4.
Рис. 4. Создания соединения с сервером
Следующие заголовки отправляются клиентом для установления рукопожатия см. рис. 5:
Рис. 5. Заголовки установления рукопожатия
Теперь, когда клиент и сервер соединены взаимными рукопожатиями, соединение WebSocket
может передавать сообщения по мере их получения, тем самым выполняя вторую программу протокола WebSocket.
WebSockets - один из самых интересных и удобных способов реализации возможностей приложения в реальном времени. Это дает разработчикам большую гибкость в использовании полнодуплексной связи. 