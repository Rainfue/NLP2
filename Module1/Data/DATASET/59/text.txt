Это не секрет, что PHP является довольно простым языком с точки зрения кода, однако многим молодым разработчикам не хватает знаний о принципах безопасности, что приводит к некачественному написанию веб-приложений и созданию критических уязвимостей. Рассмотрим некоторые ошибки, допускаемые разработчиками на PHP, которые приводят к уязвимостям 
удаленного выполнения кода.
Уязвимые функции
Давайте взглянем на общий класс функций, которые при использовании 
приводят к не безопасному выполнению кода. Любой ввод непроверенных 
данных через одну из этих функций – eval(), system(), exec(), shell_exec(), 
приводит к передаче этих данных без проверки, что может привести к выполнению произвольного кода [1, с. 567].
Самый явный пример – использование функции eval(). Веб-разработчики, как правило, хотят выполнить нужный код с некоторыми динамическими изменениями. Это можно рассмотреть на следующем примере:
<?php
eval("echo $name;");
?>
В этом случае, переменная будет обрабатываться как PHP-код, поэтому 
будет выводиться содержание $name.
<?php
eval('echo $name;');
?>
Во втором случае просто будет происходить вывод строки со значением $name. Таким образом, если программист хочет получить результат, описываемый во втором случае, то ему не стоит использовать 
двойные кавычки.
Экранирование eval тратит много времени и нет никакой функции в 
PHP, которая бы позволила экранировать данные в eval. В основном, проблемы такого рода возникают при выполнении таких сценариев, как:
<?php
$name = $_GET[„name‟]
system(“echo $name”);
?>
Из примера, приведенного выше, видно, что независимо от того, что передано в переменной, разработчик будет считать, что ее значение будет просто выведено на экран. Это мнение верно, но лишь до того момента, когда 
злоумышленник передаст значение типа:
“Paulos;ls –la”
для linux-систем или
“Paulos&&dir”
для Windows.
В результате этого, злоумышленник выполнит команду ls –la, потому 
как точка с запятой „;‟ означает начало выполнения новой команды, то есть 
ls -la. В результате чего будет выведено значение “Paulos”, после которого 
будет выведена структура текущего каталога [2, с. 320].
Точно так же другие функции, вроде shell_exec() или exec() могут привести к подобного рода уязвимостям.
Регулярные выражения
Один из популярных случаев необходимости оценки безопасности кода –
использование регулярных выражений. Выражения используются довольно 
часто из-за удобства – гораздо проще написать одну сложную конструкцию, 
вместо нескольких простых. Множество фильтров веб-приложений и брандмауэров основываются на регулярных выражениях.
тся устаревший, но еще встречающийся модификатор "e" у preg_replace(), 
который после выполнения стандартных подстановок в заменяемой строке 
интерпретирует ее как PHP-код и использует результат для замены искомой 
строки.
<?php
$name='<p>phpinfo()</p>';
preg_replace("/<p>(.*?)<\/p>/e",'addslashes(\\1)',$name);
?>
Очевидно, намерение разработчика было направлено на экранирование 
входного значения с помощью addslashes [4, с. 179]. Даже если нет модификатора 'e', иногда можно выполнить произвольный код на стороне сервера с 
помощью записи нулевого байта в регулярное выражение.
<?php
$replace=$_GET['re'];
$name='<p>phpinfo()</p>';
preg_replace("/<p>(.*?)$replace<\/p>/",'\\1',$name);
?>
Этот пример легок и интуитивно-понятен, но необходимо показать, как 
атака с помощью нулевого байта может работать. Уязвимый код принимает 
запрос следующим образом:
http://localhost/index.php?re=<\/p>/e %0
Функциональные задачи
Функциональные задачи, один из способов, как может происходить выполнение кода, рассмотрим следующий пример:
<?php
$name=$_GET[„name‟];
$argument=$_GET['argument'];
$name($argument);
?>
В случае, если register_globals включен, предыдущий код эквивалентен 
этому:
<?php $name($argument);?>
Отсюда возникает следующая уязвимость:
$name становится именем функции и $argument – аргумент имени, откуда понятно, что эта конструкция может делать.
В другом случае с помощью create_function(), становится возможным 
создание анонимной функции. Пример:
<?php
$name=$_GET['name'];
$create =create_function('$name',"echo $name;");
$name('');
?>
Тогда следующий запрос выдаст результат phpinfo()
http://localhost/index.php?name=phpinfo()
В eval() это может быть эквивалентно такому:
<?php
eval("function this_is_so_safe() {
echo phpinfo();
}");
this_is_so_safe();
?>
PHP-Includes
В PHP есть некоторые функции, используемые для динамического подключения PHP-кода внутрь страницы. Если входящие данные используются 
для динамического подключения файлов внутрь страницы, это приводит к 
уязвимости php-include. include(), iclude_once(), require(), require_once() и 
другие – функции, к обработке входящих данных которых нужно относиться с осторожностью [3, с. 136].
Лучший способ защититься от такого рода атак – избежание динамических путей к файлам. Если же это невозможно, то использование таких 
включений должно быть ограниченным и необходимо проверять достоверность включенных файлов. Кроме того, необходимо использовать абсолютные пути вместо относительных. Если же это не проверяется, вы никогда не 
узнаете, по какому пути выполнится запрос. Правильный подход к подключению файлов заключается в следующем:
<?php
define('MY_FILE_PATH','/var/www/htdocs/');
require_once(APP_PATH .'lib.php');
?>
Теперь рассмотрим пример с другой страницей:
http://localhost/index.php?file=page1
page1 это файл, который динамически подключен к странице, взглянув 
на url можем предположить, как выглядит код в данном случае:
<?php
$page_to_include=$_GET['file'];
require_once($page_to_include.'.html');
?>
А теперь представим, что взломщик изменяет значение переменной 
“file”:
http://localhost/index.php?file=data:text/plain,<?php phpinfo();?>
Подключение локального файла легко может быть преобразовано в удаленное выполнение кода. Однако, этот способ может не сработать, если в 
настройках PHP установлено allow_url_include=off.
Есть и другие варианты передачи, и последующего использования 
вредоносного кода, через лог-файл apache с использованием "/proc" 
файлов и других. Без сомнения, неприемлемо использование функций
file_get_contents() и readfile(), и других функций подключения удаленных 
файлов без должной фильтрации входящих параметров.