Все мы знаем, как работает сеть – браузер отправляет запрос, а сервер возвращает ответ. Если была запрошена веб-страница, ответ содержит HTML-код,
который затем используется браузером для отображения веб-страницы.
Но как возвращаемый HTML-код попадает на сервер? Генерируется ли он
«на лету» (по запросу)? Является ли он «предварительно сгенерированным»
(т.е. загружены ли готовые HTML-страницы на сервер)?
В современном мире веб-разработки существует три основных способа рендерить веб-сайты и необходимый HTML-код:
Первый вариант – это «динамические страницы», HTML для которых создается динамически на сервере с помощью серверного языка программирования и
«шаблонизатора».
Второй альтернативой являются «одностраничные веб-приложения» (SPA –
Single Page Application). Сервер всегда возвращает одну предварительно сгенерированную HTML-страницу, которая содержит код JavaScript, динамически
изменяющий страницу в браузере.
И третьим способом являются «статичные страницы», которые были предварительно сгенерированы и сохранены как таковые на сервере – обычно эти
страницы не пишутся вручную, а также генерируются автоматически (но до их
загрузки) с помощью генератора статических сайтов.
Для начала рассмотрим динамические веб-страницы. При таком подходе,
веб-страница, которую вы просматриваете, динамически создается на сервере,
включая информацию о том, какие стили и скрипты подключать.
Обратите внимание на свой профиль пользователя в любом интернетмагазине, например, shein.com. Он включает в себя ваши личные данные, такие
как ваше имя и историю заказов. Очевидно, что Shein не пишет HTML-код для
этой страницы вручную. Тем не менее, если вы просмотрите исходный HTMLкод этой страницы, вы найдете там свои личные данные.
Это означает, что HTML-код был динамически сгенерирован на сервере с
помощью используемого там серверного языка. Входящий запрос обрабатывался сервером в соответствии с инструкциями используемого там языка. Он был
проанализирован, и необходимые данные (например, ваше имя) были извлечены из базы данных. Затем сервер использовал всю эту информацию для генерации динамического HTML-кода, который возвращался в ответ, ожидаемый
браузером.
Для этого можно использовать серверные языки, такие как Node.js, обычно
в сочетании с определенными расширениями, упрощающими динамическое создание HTML-кода, которые называются «шаблонизаторами».
Преимущество такого подхода в том, что клиент (браузер) получает готовый сайт со всеми данными, которые ему принадлежат. Это особенно важно,
если клиент не пользователь, а поисковый робот анализирующий контент
(HTML-код), который должен увидеть пользователь, и продвигает страницу в
поисковых системах (конечно, он не увидит вашу личную страницу профиля,
но та же концепция применима и к другим страницам).
Еще одно преимущество заключается в том, что вся логика выполняется на
сервере, поэтому клиентской машине необходимо отображать только HTMLкод. Эта задача обычно не слишком требовательна к производительности.
Недостатком этого подхода является то, что каждая страница, которую посещает пользователь, должна быть создана на сервере. Это означает, что пользователю всегда приходится ждать отправки новой страницы. Современные
серверы и браузеры довольно хороши в этом (например, они используют кэширование, чтобы избежать ненужных запросов и циклов), но, тем не менее, у
сервера есть дополнительная работа. Даже если меняется только одна деталь на
странице, а фрейм остается прежним (например, панель навигации, шапка и
подвал сайта), тем не менее необходимо запрашивать и отображать новую
страницу целиком.
Кроме того, еще одним недостатком может быть то, что разработчикам, создающим динамические страницы, нужны знания как клиентского интерфейса
(HTML + CSS + JS), так и серверного. Работа по их разделению, безусловно,
возможна, но зависимость интерфейсов немного выше.
Одностраничные приложения (SPA) представляют собой другую крайность:
в них вся генерация HTML происходит в браузере. Сервер возвращает только
одну базовую HTML-страницу для всех входящих запросов (независимо от
URL-адреса).
Но эта единственная HTML-страница содержит много кода JavaScript
(обычно вынесенного в отдельные файлы), который отвечает за изменение кода
HTML (технически DOM).
Поначалу это звучит странно, не так ли? Раньше сервер извлекал данные из
базы данных, чтобы затем сгенерировать HTML-код. Теперь этим должен заниматься клиент (браузер)?
Важно понимать, что в SPA по-прежнему задействован сервер. Код
JavaScript на стороне клиента не будет подключаться к базе данных, так как это
было бы очень небезопасно. В таком случае учетные данные доступа были бы
раскрыты, поскольку вы не можете скрыть свой клиентский код JavaScript.
Но весь процесс обновления пользовательского интерфейса будет происходить в браузере. Это обеспечивает пользовательский опыт, аналогичный мобильному приложению, поскольку пользователю больше не нужно ждать загрузки новой страницы. Вместо этого обновления и изменения происходят
мгновенно.
Вашему приложению, вероятно, время от времени все еще будут нужны некоторые данные, но вы можете просто показывать уведомление о загрузке в
пользовательском интерфейсе, пока эти данные не будут получены за кулисами
(например, через AJAX).
Поскольку для динамического обновления всей HTML-страницы с помощью кода JavaScript на стороне клиента требуется довольно много кода
JavaScript, обычно используют фреймворк или библиотеку для тяжелой работы.
React.js, Angular, Vue.js и Svelte – самые популярные варианты.
Сейчас SPA находятся на подъеме, потому что они обеспечивают такой
удивительный и быстрый пользовательский опыт. Но у обработки всех обновлений пользовательского интерфейса и рендеринга контента в браузере есть и
свои недостатки.
Самым большим недостатком является то, что страница, которую вы отправляете по сети (т.е. та исходная одиночная HTML-страница, которая запускает SPA), почти полностью пуста. Как правило, это не более чем один HTMLтег, в который будет рендериться интерфейс, и пара импортируемых скриптов и
стилей.
Это очень плохо для SEO, так как поисковый робот не видит весь ваш красивый контент, который в конечном итоге будет отображаться – вместо этого
он просто видит пустую страницу. Некоторые поисковые роботы могут фактически ждать, пока JavaScript запустится и отобразит что-то, но они никогда не
будут ждать асинхронно загруженных данных (т.е. контента, который сначала
должен быть получен с помощью скрытого HTTP-запроса).
Есть решения этой проблемы – например, рендеринг SPA-представлений на
стороне сервера. Но это уже звучит немного более продвинуто – и это действи-
тельно так. К счастью, есть технологии, которые немного упрощают этот процесс и, следовательно, позволяют вам получить лучшее из обоих миров. Самыми популярными решениями для различных фреймворков являются Next.js в
React.js, Nuxt.js во Vue.js и Angular Universal в Angular.
Помимо «проблемы» SEO, также стоит упомянуть, что увеличение объема
работы в браузере означает необходимость загрузки большего количества кода
JavaScript. И весь этот код должен быть проанализирован и выполнен, что, конечно же, влияет на производительность веб-сайта. Таким образом, на более
медленных устройствах и/или в более медленных сетях SPA может очень долго
загружаться или «подвисать».
Для решения этой проблемы необходимо применять различные подходы по
оптимизации приложений, например, отложенную загрузку и декомпозицию
компонентов.
Статические страницы – старейшая форма веб-страниц. В конце концов, статическая веб-страница просто означает, что весь HTML-контент уже создан. Готовые страницы затем загружаются на сервер и ждут запросов на их получение.
Если вам нужен очень простой веб-сайт, контент которого меняется нечасто
и у вас также нет динамического (например, пользовательского) контента, такой статической страницы вам может быть достаточно.
Но теперь самое интересное: даже страницы с динамическим содержимым
можно преобразовать в статические страницы, с помощью вышеупомянутых
технологий серверного рендеринга.
Каждый генератор работает по-своему, например, Gatsby.js на самом деле
использует приложение React, которое он в основном создает локально, а затем
«посещает» каждую страницу, которая существует в SPA. Снимки этих страниц
затем сохраняются в виде HTML-файлов – и это окончательный результат его
работы. Затем эти файлы просто загружаются на сервер для дальнейшей отправки клиенту.
По сравнению с обычным SPA подход со статической страницей имеет большое преимущество: последняя страница отправляется по сети по запросу. Не
нужно запускать код JavaScript, чтобы отобразить его на экране. Поэтому сканеры
поисковых систем видят то, что видят пользователи. И пользователям не нужно
ждать, пока начальный код JavaScript будет проанализирован и выполнен.
Но лучше всего то, что некоторые статические страницы после загрузки
превращаются в SPA. Следовательно, вы получаете все преимущества SPA
(быстрые обновления, мгновенные изменения), как только пользователь загрузит первую страницу. Но для этой первой страницы вы получаете преимущества статической или динамической веб-страницы.
Однако, статическая страница – независимо от того, создана она с помощью
генератора статических сайтов или без него, может быть плохим выбором для
веб-сайта, содержимое которого меняется несколько раз в час или минуту. Даже если процесс в высокой степени автоматизирован, страницу придется посто-
янно перегенерировать и повторно развертывать! Динамическая страница или
SPA могут быть здесь лучшей альтернативой!
SPA в целом часто является достойным выбором – он особенно хорош для
веб-приложений, которые на самом деле не нуждаются в сканировании поисковыми системами.
Вы всегда можете создать свои целевые страницы (которые должны быть
найдены) удобным для SEO способом (например, статические страницы) и создать остальную часть приложения как SPA. Прекрасная реактивность и UX
делают SPA отличным выбором для браузерных приложений, таких как Google
Docs, лента Twitter или Netflix.
С другой стороны, динамическая страница может быть идеальной, если у
вас быстро меняющийся контент, а SEO имеет большое значение. Например,
интернет-магазин.
Как всегда в жизни, не помешает знать все эти альтернативы – это позволит
вам выбрать правильный инструмент для проекта, над которым вы работаете.