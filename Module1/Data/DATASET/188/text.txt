На текущий момент развития платформы Node.js и экосистемы языка Javascript в
целом сообщество разработчиков пришло к заключению, что введение статической
типизации и объектно-ориентированного подхода необходимо ввиду причин, которые
будут рассмотрены далее в статье. Однако существует только небольшой набор
исследований, которые раскрывают особенности использования данной парадигмы
программирования и в большей мере сосредоточены на представлении инструментов
как таковых [1]. Ввиду этого данное исследование направлено на поиск и анализ
проблем внедрения статической строгой типизации при создании серверныхприложений на платформе Node.js. Основным подходом исследования является
построение идентичных по функциональности приложений на различных технологиях
с целью определения возможных преимуществ и недостатков каждого из подходов.
В исследовании ставятся следующие задачи:
• определить особенности различных видов типизации языков в общем виде;
• обозначить проблемы статической серверной типизации платформы Node.js;
• привести преимущества и недостатки использования статической типизации
при разработке веб-систем.
Прежде чем рассмотреть преимущества, недостатки и реализацию статической
типизации Javascript (далее JS) при разработке приложений на платформе Node.js,
необходимо определить общие виды типизации и их особенности. Вид
типизированного языка может быть определен исходя из следующих трех категорий
типизации: статическая или динамическая; сильная или слабая, которая также известна
как строгая или нестрогая; явная или неявная [2]. Ниже следует краткое пояснение
особенностей каждой из групп.
Основное отличие статической и динамической типизаций в том, что для первой
характерно определение и установка типов всех переменных и аргументов функций на
этапе компиляции, тогда как при динамической типы определяются во время
исполнения кода программы. Из этого следуют такие преимущества статической
типизации, как: единственная проверка типов, которая происходит на шаге
компиляции, что позволяет отловить все ошибки связанные с типами до исполнения
кода; немного более высокая скорость исполнения в сравнении с динамической
типизацией; поддержка при разработке на основе сравнения типов. Также можно
выявить преимущества динамической типизации, а именно: нативное создание
универсальных коллекций, которые могут хранить различные типы данных; простота
создания шаблонных функций, так как это могут быть любые функции.
Языки с сильной типизацией не позволяют объединять в выражениях
переменные различных типов, а также не выполняют неявные преобразования. При
этом языки со слабой типизацией самостоятельно выполняют неявные преобразования,
несмотря на то, может произойти потеря точности или неоднозначное преобразование.
Таким образом, можно определить следующие преимущества сильно типизированных
языков: надежность, которая проявляется в появлении исключения или ошибки
компиляции вместо неявного или неправильного поведения; определенность,
появляющаяся в связи с тем, что известны участки кода с преобразованиями типов,
ошибки в которых могут быть быстро детектированы. С другой стороны, существуют
следующие преимущества слабой типизации: удобство использования выражений с
несколькими типами, к примеру, целыми и вещественными числами, а также строками;
абстрагирование разработчика от проблем типизации и большая сосредоточенность на
решении задачи; более краткая и однородная запись определения переменных в
сравнении с сильно-типизированными языками.
Различие явной и неявной типизации следует из названия – языки с явной
типизацией требуют явное определение типов переменных и аргументов функций в
коде, тогда как при неявной типизации это производится движком, компилирующим
или интерпретирующим программу. Могут быть выделены следующие преимущества
явной типизации: наличие сигнатуры, определяющей типы аргументов функций,
позволяющих быстрее выявлять ее назначение. Преимущества неявной типизации
состоят в сокращении записи переменных и аргументов функций, так как указание
типов не требуется; при изменении типа переменной или аргумента не требуется
создание отдельного метода или шаблонной функции.
Язык JS, который исполняется на платформе Node.js, а также в браузере,
является языком с динамической слабой неявной типизацией. Это имеет своипреимущества, как это было описано выше. Однако с развитием веб-технологий,
усложнением клиентских приложений, над которыми могут работать одновременно
сотни разработчиков, появлением крупных клиентских фреймворков, которые
используют компонентный подход, вписывающийся в парадигму объектноориентированного программирования, появился проблема внедрения статических
типов и синтаксически удобного объектного подхода в JS. Вследствие этого получили
широкое распространение инструменты внедрения статической типизации в JS, а
именно Flow и Typescript (далее TS) [3, 4]. Также требуется упомянуть, что под
статической типизацией далее будет подразумеваться статическая строгая явная
типизация.
Инструмент Flow является статическим анализатором кода, который проверяет
введенные типы на основе аннотаций и тегов, проставленных разработчиком. Это
позволяет минимально влиять на структуру JS кода. Язык TS является надмножеством
языка, которое компилируется в JS. Таким образом, язык TS в большей степени влияет
на изменение кодовой базы проекта, внося значительные изменения в способ
разработки приложений. Далее будут рассматриваться проблемы использования
статической типизации на TS, а не на Flow, так как:
1. TS имеет больший и более поддерживаемый набор определений типов для
библиотек и фреймворков.
2. Flow имеет менее точную документацию относительно TS.
3. Мало документированная работа с модулями у Flow, в отличие от TS, что
немаловажно для серверных приложений.
4. TS закрепился в сообществе разработчиков как основной инструмент
перехода от динамической типизации к статической в серверном JS.
5. Согласно статистике менеджера пакетов платформы Node.js на момент
написания статьи недельное количество скачиваний корневого модуля Flow составляло
600 тысяч, тогда как TS – 10 миллионов.
Тем не менее, необходимо отметить, что последующие проблемы использования
статической типизации в серверных проектах на Node.js справедливы и для Flow.
Несмотря на то, что статические типы имеют большое количество
положительных аспектов, включение их в Node.js приложения сопряжено с появлением
некоторых затруднений, замедляющих и усложняющих разработку.
Первая проблема появляется на начальном этапе, а именно при инициализации
проекта. В клиентской разработке на JS несколько лет назад стал стандартом шаг по
транспиляции кода в формы, которые могут исполняться браузерами, а также возможно
устаревшим браузерами, так как требуется поддержка широкого круга клиентов [5].
Однако на серверной стороне, где код выполняется на заранее известной платформе,
любые дополнительные манипуляции с кодом, даже статическая проверка, являются
избыточными, так как все фреймворки поддерживаются последними версиями Node.js,
а также изменяются согласно нововведениям.
Однако внесение в проект статической типизации заставляет разработчика
подключать дополнительные зависимости, писать конфигурационные файлы, а также
настраивать автоматизацию проверки типов при изменениях перед запуском
приложения, что сказывается на скорости разработки, особенно на начальных этапах.
Также в случаях с небольшими проектами и микросервисами, которые являются
крупной долей использования Node.js, данная проблема может являться решающим
фактором отказа от статической типизации в пользу динамической.
При этом, учитывая тот факт, что увеличивается время развертывания и запуска
проекта, существует потенциальная возможность по дальнейшему ускорению
разработки, которая отражается в снижении времени на отладку ошибок,
появляющихся при неверном использовании типов из собственных модулей.