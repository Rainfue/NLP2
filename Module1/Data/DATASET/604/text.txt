Асинхронная концепция применяется во многих веб-платформах: JavaScript, C#, Python.
Чаще всего с идеей асинхронности связывают именно язык JavaScript и платформу Node.js,
которая позволяет писать эффективные в плане производительности и масштабируемые
приложения. Платформа Node.js хорошо подходит для создания различных видов
приложений: веб-приложения, приложения командной строки и демоны, настольные или
десктопные приложения, а также приложения реального времени. Однако PHP, благодаря
своей простоте и большому функционалу, долгое время оставался лидером в сфере back-end
разработки. Данная технология в той или иной степени задействована более чем на 80%
сайтов, которые до сих пор нуждаются в обслуживании и развиваются. Таким образом, может
возникнуть необходимость внедрения асинхронного функционала в существующее PHPприложение, что удобнее всего будет сделать именно на PHP, в чем могут помочь
асинхронные PHP-библиотеки.
Изначально язык PHP основан на синхронной концепции, которая блокирует
выполнение кода, пока не будет получен ответ на отправленный запрос. Избавиться от
блокирующих операций позволяет асинхронность. Ключевая идея асинхронного
программирования – возможность запускать вызовы методов и продолжать работу
приложения, не дожидаясь окончания вызовов. Асинхронный ввод/вывод – это концепция
обработки данных ввода/вывода, которая позволяет коду выполнять другие задачи, пока
совершается обработка запроса. Асинхронные операции позволяют увеличить производительность процессора за счет использования времени ожидания ответа на
выполнение других задач, т.е. в асинхронном программировании задачи могут выполняться
некоторыми дискретными порциями, освобождая вычислительные ресурсы процессора, когда
они ожидают ответ на запрос.
Традиционный процесс запрос-ответ к PHP-приложению происходит по следующему
сценарию: клиент отправляет запрос серверу, сервер запускает нужный PHP-скрипт, который
возвращает данные серверу, а сервер, в свою очередь, отправляет их клиенту. Таким образом,
получается, что для каждого запроса запускается отдельный процесс, который уничтожается,
закончив работу. Этот подход сильно отличается от подхода Node, где приложение запущено
в одном процессе и ждет, когда произойдет событие. В традиционной модели PHP роль
слушателя событий перенесена непосредственно на веб-сервер, который при получении
запроса запрашивает требуемый PHP-скрипт. Несложно заметить, что в данной модели
тратятся ресурсы веб-сервера и временные ресурсы на запуск скрипта, получение ответа и
завершение процесса. Асинхронная концепция также решает данную проблему. Язык PHP
пока не располагает инструментами на уровне языка для написания асинхронных приложений,
однако, предоставляет большой набор асинхронных библиотек и инструментов: ReactPHP,
Amphp, Swoole, Kraken и др.
ReactPHP – это библиотека языка PHP, представляющая собой набор компонентов для
событийного программирования на PHP [1]. К ключевым компонентам библиотеки относятся
цикл событий (event loop), promise и потоки.
Цикл событий – это программная конструкция, которая ожидает возникновения и
производит рассылку событий или сообщений в исполняемой программе. Event loop в
ReactPHP не скрыт, поэтому необходимо явно его объявлять [1]. Event loop выполняется до
тех пор пока циклу есть, что обрабатывать. Когда все инициализированные обработчики
событий выполнены, event loop останавливается и управление кодом возвращается в
синхронный режим.
Promise в ReactPHP основаны на двух концепциях: deferred, promise [1]. Deferred
представляет собой единицу работы или вычислений, которая, возможно, еще не завершена
или еще не начата. Данная работа или вычисление выполняется асинхронно и завершается в
некоторый момент времени в будущем. Если deferred представляет собой само вычисление, то
promise – это результат этого вычисления. В ReactPHP promise обычно реализуется именно
через deferred. На promise в ReactPHP основана работа таких компонентов как DNS и
Filesystem [1].
Потоки позволяют упростить использование цикла событий. В ReactPHP потоки похожи
на реализацию потоков PHP на уровне языка, но адаптированы для асинхронного
неблокирующего ввода/вывода [1]. В ReactPHP доступны реализации потоков для чтения,
записи и дуплексные. Также ReactPHP поддерживает возможности пайпинга. Пайпинг – это
механизм, средствами которого выходные данные одного потока передаются в качестве
входных другому.
Amphp – это неблокирующий PHP-фреймворк [2]. Как и ReactPHP предоставляет
ключевые компоненты для написания асинхронного кода: event loop, потоки и promise.
Сочетая promise с генераторами, фреймворк формирует корутины, позволяющие писать
асинхронный код синхронным способом, т.е. без необходимости использовать коллбэкфункции [2]. Корутины являются прерываемыми функциями, похожими на генераторы. С
помощью генераторов обычно реализуются простые итераторы, и создаются значения с помощью ключевого слова yield. Amp использует yield как точку прерывания. Когда в
coroutine-функции возникает значение, выполнение функции прерывается, и выполняются
другие задачи (обработчики ввода/вывода, другие функции-корутины) [2]. Функциюкорутину от генератора отличает возможность передавать параметры (с помощью метода
send()) из внешнего кода каждый раз, когда функция выбрасывает очередное значение.
Swoole – высокопроизводительный фреймворк, написан на языке С как расширение PHP
[3]. Используя Swoole можно писать высокопроизводительные и масштабируемые TCP, UDP,
HTTP, WebSocket сервисы. В отличие от Nginx, Tornado, и Node.js, Swoole имеет встроенные
асинхронные многопоточные модули ввода/вывода. Как и Amphp, фреймворк основан на
корутинах. Swoole создает одну coroutine-функцию для каждого запроса и переключается
между ними, основываясь на статусе ввода/вывода [3].
Язык PHP предоставляет достаточно большой набор инструментов для написания
асинхронных приложений с неблокирующим вводом/выводом. Наиболее проста в изучении –
библиотека ReactPHP. Данная технология предоставляет функционал, аналогичный
функционалу языка JavaScript и платформы Node.js. Однако, несмотря на эффективность
платформы Node.js, есть ситуации, когда платформе Node лучше предпочесть другую
технологию. В PHP-приложении это может быть необходимость оптимизировать затраты вебсервера и временные ресурсы. В случае необходимости опытный PHP-разработчик скорее
освоит новую технологию знакомого и более привычного языка, чем перейдет на новую
платформу.
Таким образом, можно сформулировать следующие рекомендации. Использовать
асинхронные PHP-технологии можно в случаях:
1. необходимости внедрения в PHP-приложение асинхронного функционала, чтобы не
добавлять в приложение другую платформу, основанную на менее знакомой PHPразработчику технологии, что позволит упростить поддержку приложения;
2. необходимости написания PHP-приложения с неблокирующим вводом/выводом;
3. если PHP-разработчик желает повысить свою квалификацию. Для новичков в асинхронных
библиотеках PHP лучше всего подойдет именно ReactPHP с лучшей документацией и более
развитым сообществом;
4. в исследовательских целях для поиска альтернатив платформе Node.js.
Рассматривая перспективы асинхронности в PHP, следует отметить заинтересованность
разработчиков во внедрении нового функционала в язык. Один из разработчиков языка PHP
Зеев Сураски в июне 2018 года опубликовал письмо, в котором поделился планами команды
в отношении языка и перспективах. Главная новость данного письма – это готовность команды
разработчиков завершать линейку PHP7 и переходить к разработке новой версии языка PHP8
[4]. В планах на новую версию внедрение компиляции на лету (JIT), которая позволит PHP
улучшить свою производительность в рамках разработки, выходящей за пределы веба, а также
асинхронность [4]. В письме говорится, что необходимо добавить больше поддержки операций асинхронного ввода/вывода непосредственно в сам язык, чтобы расширить круг
задач, где в настоящее время имеет смысл применять такие инструменты как ReactPHP, Amphp
или Swoole [4]. Таким образом, платформа PHP развивается и готова выйти на новый этап
своего жизненного цикла. Внедрение асинхронности в PHP позволит платформе дольше
оставаться востребованной на рынке веб-разработки, а также внедрять новый функционал в
уже существующие PHP-приложения.
