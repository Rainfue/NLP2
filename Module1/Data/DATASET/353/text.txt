ECMAScript 6 – это крупное обновление языка JavaScript, в ходе этого он сильно
видоизменился, ему устранили баги и некоторые синтаксические ошибки. Давайте рассмотрим
основные добавления в язык программирования JavaScript.
Начнем с промисов, они же Promises. Промисы позволяют разработчикам программы брать
огромное нагромождение из callback функций. Так как бывают ситуации, где одна callback
функция должна идти за предыдущей, и чтобы это организовать раньше использовались
вложенные callback функции. Но когда много кода становиться трудно читать большое количество
вложений. У такой проблемы есть название callbackhell. Чтобы с кодом лаконично работать и была
добавлена в стандарт функция создавать промисы.
Например, этот код можно написать по-другому без вложений через промис.
setTimeout(function () {
console.log("это отобразится через 1 секунду");
setTimeout(function () {
console.log("это отобразится через 2 секунды");
 }, 1000);
}, 1000);
Переделали на это, используя промисы:
const prom = () =>
 new Promise((resolve, reject) => {
setTimeout(resolve, 1000);
 });
prom()
.then(() => {
console.log("это отобразится через 1 секунду ");
return prom();
 })
.then(() =>console.log("это отобразится через 2 секунды"));
В промисах есть два параметра – это resolve и reject, вот синтаксис создания нового
промиса.
newPromise((resolve, reject)
Через параметр resolve можно указать условие, при котором промис считается
выполненным успешно, а через параметр reject можно указать условие, при котором промис
отменен. Когда промис срабатывает то выполняется метод then(), а когда промис отменяется
срабатывает метод catch().
Внутри промисы, как правило бывают написанные блоки кода которые описывают тело
условий, и логику, а логика в свою очередь решает, как решить промис, через условие при котором
он выполняется, или через условие при котором промис считается не выполненным. Промис, как
бы позволяет получать результат действий асинхронных методов, так как будто мы работаем с
синхронным методом.
Сейчас рассмотрим работу Generator. Generatorfunction эта функция возвращает
Generatorobject. Чтобы указать компилятору, что ваша функция будет Generator нужно указать *
после функции.
function* Genfunction(parm) {
 statements
}
Синтаксис Generator функции.
Generator – это функции из которых можно в определённый момент выйти, и затем в
определенный заданный программистом момент войти. Переменные и их значения сохраняются
при дальнейших входах.
JavaScript был языком без классов, с функциональным подходом, и в ES6 добавили
возможность создания классов, это по сути является так называемым синтаксическим сахаром. По
сути классы в JavaScript - это те же функции, так как через прототипы уходят к главному
прототипу, который является базой из функционального подхода. Язык программирования
JavaScript являлся самым известным прототипированным языком, а теперь его синтаксис обновлен
классами, благодаря которым появилась возможность грамотного объектно-ориентирного
программирования.
Возможность наследования выглядит теперь более интуитивно, как в других объектноориентирных языках программирования.
class Person {
constructor(firstName, secondName) {
this.firstName = firstName;
this.secondName = secondName;
 }
hello() {
 return "Приветя " + this.firstName, this.secondName + ".";
 }
}
class Developer extends Person {
hello() {
 return super.hello() + "Ястудент.";
 }
}
const me = new Developer("Магомед, Магомедов");
console.log(me.hello());
Удобство JavaScript при использовании на нём классов заключается в том, что переменные
не нуждаются в явном объявлении. Но если мы говорим об конструкторе класса (это тот же метод,
только название у которого одноименное с классом, и он инициализирует свою работу каждый
раз, когда создается новый экземпляр класса, то есть объект) то мы должны обязательно
инициализировать все переменные внутри конструктора. Конструкторы имеют особый метод под
названием constructor. Обычно конструктор наследуется сам по себе без строгого указания
наследования. Если класс потомка имеет собственный конструктор, то чтобы унаследовать от
родителя конструктор используют метод super(), с сохранением аргументов, того родителя от
которого мы хотим унаследоваться. Метод super(), также используется для того, чтобы вызвать
функции, которые принадлежат главному наследнику или главному прототипу.
Если затронули тему объектно-ориентирного программирования, то геттеры и сеттеры тут
как тут. Getter и setter – это методы внутри класса, которые выполняют как правило лишь одну
функцию, либо установка, либо получение данных.
Синтаксис get:
class Person {
 get allData() {
 return {`${this.Data}
${this.Data2}`};
 }
}
С помощью get можно получить данные из полей класса, и присвоить их переменной
объекта класса.
Синтаксис set:
class Person {
 set name(firstName) {
this.theName = firstName;
 }
}
С помощью set можно установить данные в поля класса, из инициализированного объекта
этого класса.
В ES6 добавили модули, раньше было 3 модуля:
- AMD
- RequireJS
- CommonJS
И в ES6 их сделали в общем стандартном формате, чтобы облегчить работу с ними. Чтобы
импортировать модули синтаксис очень прост, потому что используют ключевое слово import.
Не смотря на то, что ECMAScript тру программисты считают забагованным и не
походящим для нормальной строгой разработки, он все-таки дополняется и изменяется с каждым
годом, так как его поддержка продолжается. В настоящее время уже исправлены множество
ошибок и проблем языка, его можно использовать самостоятельно для некоторых проектов. 