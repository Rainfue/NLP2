У Node-приложений имеются те же уязвимости, которые присущи
JavaScript-приложениям на стороне клиента, а также дополнительные
уязвимости, связанные с серверными приложениями, использующими системы
баз данных, особенно системы реляционных баз данных. [1]
Чтобы обеспечить безопасность приложения, нужно предоставить
надежные системы аутентификации и авторизации. Но столь же важно защитить приложение от инъекционных атак и других попыток использования открытых
мест вашей системы для доступа к важным и конфиденциальным данным.
Раньше форма регистрации получала текст непосредственно от
пользователя и вставляла его в SQL-запрос. Это было далеко не самым мудрым
решением, потому что человек мог ввести текст, способный нанести вред базе
SQL-данных. [2]
То же самое случается при обработке текста или JSON-строки, получаемой
от пользователя, или исходного кода в JavaScript-инструкции eval; входная
строка может принести больше вреда, чем пользы.
Обе разновидности уязвимостей требуют, чтобы мы очистили вводимые
данные перед их использованием в условиях, когда они могут нанести вред. Обе
они также требуют применения средств и технологий, обеспечивающих
максимальную безопасность приложений. [3]
Независимо от того, относятся ваши JavaScript-приложения к Node или
нет, для них есть одно простое правило: откажитесь от использования функции
eval. Функция eval является наименее защищенным и наиболее либеральным
JavaScript компонентом, поэтому нужно относиться к ее применению со страхом
и трепетом. [3-4]
В большинстве случаев функция eval вам не потребуется. Один из
примеров, где она могла бы пригодиться, связан с конвертацией JSON-строки в
объект. Но есть весьма простой способ защиты от инъекционных JavaScript-атак
при конвертации строки в объект: использовать для обработки входной JSONстроки не функцию eval, а метод JSON.parse. Функция eval не распознает то, что
включено в текст, а вот JSON.parse проверяет, что JSON-строка это только JSONстрока:
var someObj = JSON.parse(jsonString);
Поскольку Node использует движок V8, мы знаем, что у нас есть доступ к
JSONобъекту, поэтому насчет всех этих межбраузерных ухищрениях нам
волноваться не стоитСогласно второму простому правилу разработки веб-приложений нужно
стремиться минимизировать возможности ввода в веб-форму произвольного
текста. Вместо открытых текстовых полей следует предлагать пользователю
раскрывающиеся списки, флажки и переключатели. Тем самым гарантируется не
только безопасность данных, но также их целостность и надежность
Например, в форму все данные вводятся в виде открытого текста. Одно из
полей предназначено для сохранения идентификаторов, если они приемлемы.
Размытость понятия «приемлемости» будет крахам приложения.
Если нужно, чтобы пользователь вводил в поля произвольный текст,
например имя пользователя при его входе в систему, нужно очищать данные
перед их использованием в инструкции обновления данных или в запросе. [5]
Очищайте и санируйте данные с помощью модуля node-validator
Если без текстовых полей ввода не обойтись, перед использованием
введенных данных их следует очистить. Модуль node-mysql предоставляет метод
client.escape, который экранирует введенный текст и защищает от
потенциальных инъекционных SQL-атак. Можно также отключить
потенциально разрушительную функциональность.
Нужно также применять средства проверки, которые не только
гарантируют безопасность входных данных, но и обеспечивают их целостность.
[6]
Код из песочницы
Для безопасного помещения JavaScript-кода в песочницу служит Nodeмодуль vm. Он предоставляет доступ к новой виртуальной машине движка V8, в
которой можно запустить JavaScript-код, передаваемый в качестве параметра. [4-
6]
Есть два варианта использования модуля vm. В первом случае метод
vm.createScript вызывается со сценарием, переданным методу в качестве
параметра. Модуль vm компилирует его и возвращает объект сценария,
представляющий сценарий:
var vm = require('vm'); var script_obj = vm.createScript(js_text);
Затем сценарий можно запустить в отдельном контексте, передав ему в
качестве дополнительного объекта любые данные, которые ему могут
понадобиться:
script_obj.runInNewContext(sandbox);