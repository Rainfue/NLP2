Подавляющее большинство современных веб-приложений на клиентской стороне
разрабатываются с помощью библиотек создания пользовательских интерфейсов React,
Vue и Angular. Данные фреймворки пропагандируют паттерн Single Page Application.
Клиент изначально получает HTML-документ, после чего тот наполняется содержимым
посредством AJAX-запросов к серверу. Навигация внутри сайта не вызывает загрузки
новой страницы, а приводит лишь к обновлению текущих компонентов или же
монтированию новых.
Рендеринг на стороне клиента (Client-side rendering или же CSR) означает
рендеринг страниц непосредственно в браузере с помощью JavaScript. Вся логика
приложения, загрузка данных, маршрутизация происходят на стороне клиента. CSR
является стандартом для большинства разрабатываемых в современном мире приложений,
однако имеет ряд недостатков:
1. проблемы с поисковой оптимизацией (SEO), так как поисковые роботы не
дожидаются асинхронной загрузки данных, а индексируют сайт по первоначально
полученному HTML-документу;
2. пользовательский опыт не является оптимальным, ведь изначально
загруженная страница не содержательна и пользователю необходимо дожидаться загрузки
контентной части;
3. скорость полноценной загрузки страницы также не является оптимальной,
так как последовательность обращений к серверу в большинстве случаев медленнее
изначального получения всех необходимых данных в HTML-документе.
Серверный рендеринг (Server-side rendering) стремится решить все эти проблемы,
генерируя весь контент страницы на сервере и предоставляя пользователю уже
наполненный контентом HTML-документ, после чего происходит процесс регидратации и
к элементам страницы привязываются обработчики событий, она становится
интерактивной и приложение превращается в полноценное SPA, к которому привык
пользователь. Самыми известными представителями фреймворков, позволяющих создать
приложение с подобным функционалом, являются Next.js в экосистеме React, а также
Nuxt.js в экосистеме Vue. Такие фреймворки также называют изоморфными, так как
JavaScript-код приложения может использоваться как на сервере в среде Node.js, так и
традиционно на стороне клиента в браузере. Существует также огромное количество
библиотек и фреймворков, дополняющих или расширяющих функционал Next.js и Nuxt.js,
однако уже несколько лет они являются стандартом в своих экосистемах.
Однако в семействе технологий, построенных вокруг React, появился новый
фреймворк, ориентированный на серверный рендеринг. Фреймворк Remix от создателей
React Router в 2021 году получил финансирование на 3 миллиона долларов и был открыт
под лицензией MIT. Отличительной особенностью фреймворка является фокус
на эффективном и удобном получении данных во время работы приложения [1].
Remix ещё не занял даже минимальной доли на рынке, однако привлёк к себе
внимание сообщества веб-специалистов. Тому есть 4 основные причины:
1. доверие к разработчикам, которые создали самую популярную и удачную
библиотеку для маршрутизации клиентских приложений в экосистеме React;
2. актуальность и востребованность серверного рендеринга;
3. привлечение внимание инвесторов, что является редкостью среди
инструментов разработки;
4. применение лучших практик при проектировании приложений и стремление
к минимализму в использовании сторонних технологий для решения типовых задач в
вебе.
С момента появления первых новостей о Remix разработчики со всего мира
воспринимали данный фреймворк как прямого конкурента Next.js - самого известного
изоморфного веб-фреймворка, если оценивать количество “звёзд” на сервисе GitHub.
Однако Remix имеет ряд ключевых отличий, прежде всего концентрируюсь
исключительно на серверном рендеринге и не поддерживая статическую генерацию
страниц.
Популярность фреймворков, так или иначе использующих серверный рендеринг,
отображена в таблице 1. Как было сказано выше, с уверенным преимуществом лидером
является Next.js, однако стоит также отметить рост за 2021 год фреймворков Remix и
SvelteKit. Причём в публичный доступ Remix вышел только в октябре 2021 года.
Так как Remix - технология последних лет, тема разработки приложений на данном
фреймворке практически не освещена в научном сообществе. Даже в среде разработчиков
возникают трудности с поиском исчерпывающего руководства.
Данная работа нацелена на анализ ключевых особенностей и шаблонов
проектирования приложений с помощью фреймворка Remix.
Remix, как React и Next.js, предоставляет удобный интерфейс командной строки
(CLI) create-remix, с помощью которого можно создать шаблонное приложение. На
момент написания работы данный интерфейс поддерживал следующие опции:
1. выбор названия проекта;
2. выбор хостинга приложения (Remix App Server, Express Server, AWS
Lambda, Fly.io, Netlify, Vercel, Cloudflare Pages);
3. выбор между JavaScript и TypeScript;
4. согласие или отказ на автоматическую установку npm-пакетов из
зависимостей проекта.
Этого достаточно, чтобы создать шаблонный проект.
Для разработки, сборки приложения и запуска уже производственной сборки
приложения используются следующие консольные команды, соответственно:
• npm run dev;
• npm run build;
• npm start.
Структура любого приложения Remix достаточно проста. Помимо стандартных
файлов package.json, package-lock.json, описывающих любой проект на Node.js, READMEфайлов, конфигурационных файлов проекта, директории с зависимыми пакетами
node_modules, существует две предопределенные директории:
• app для логики всего приложения;
• public для хранения статических файлов.
Хочется отметить, что автор использует TypeScript, потому все приведенные и
упомянутые файлы будут иметь соответствующее расширение (.tsx и .ts вместо .jsx и .js
для JavaScript).
В директории app есть несколько обязательных файлов:
• entry.server.tsx;
• entry.client.tsx.
Файл entry.server.tsx содержит функцию-обработчик всех запросов к серверу,
вызывает все необходимые загрузчики, определяет коды и заголовки ответа HTTP, а
также возвращает подготовленную страницу, используя функцию renderToString из
библиотеки react-dom. Это входная точка всего серверного рендеринга в Remix.
Файл entry.client.tsx является входной точкой для браузерного рендеринга и
процессов регидратации. Использует функцию hydrate из библиотеки react-dom.
Файл root.tsx содержит корневую разметку всего приложения: необходимую
структуру html-документа, общие для всего приложения компоненты (навигационные
панели, к примеру), а также помеченные точки входа для загрузки дочерних компонентов.
Компоненты, функции, хуки, которые содержит библиотека remix:
• Компонент LiveReload. Необходим для обновления (быстрой пересборки)
приложения в реальном времени при внесении изменений в файловую структуру проекта.
Используется для удобства разработки. Должен быть удалён перед сборкой
производственной версии приложения или же добавлен по условию, когда переменная
среды окружения равна “development”. Имеет смысл добавлять данный компонент на
самый верхний уровень, а именно в файл root.tsx в директории app.
• Компонент Outlet. Выполняет роль точки входа для компонентов вложенных
маршрутов.
• Компонент Links. Позволяет подключать теги link в разметку документа из
компонентов вложенных маршрутов. Данный подход позволяет добавлять странице
определенные стили в зависимости от конкретного маршрута. Данный тег существует в
HTML-документе ровно до тех пор, пока открыта страница с тем компонентом,
вызвавшим его привязку. Для подключения тега необходимо сделать экспорт функции
links, которая возвращает массив необходимых ссылок (рисунок 1).
• Компонент Link для клиентской маршрутизации приложения. Обертка над
HTML-тегом a, предотвращающая стандартное поведение ссылок. Также с помощью
атрибута prefetch можно настроить загрузку данных страницы, на которую ведёт ссылка,
при рендеринге компонента с ссылкой либо при наведении на ссылку курсором
пользователя.
• Функция redirect необходима для программной маршрутизации приложения.
• Хук useParams для доступа к URL-параметрам.
• Компонент Scripts необходимо помещать в файл root.tsx директории app. Без
этого компонента приложение на Remix может работать совершенно без JavaScript, то
есть отправляя пользователю только HTML, CSS и статические файлы вроде шрифтов и
изображений. Это одно из ключевых отличий Remix от других фреймворков,
предоставляющих возможности серверного рендеринга. При грамотной разработке
приложения все мутации данных можно осуществлять с помощью HTML-форм и их
нативной обработки, нет необходимости в библиотеке хранения состояния приложения,
ведь логику приложения можно обрабатывать на сервере. Есть очевидный недостаток в
том, что без JavaScript приложение пострадает в удобстве, интерактивности, перестанет
быть SPA, однако в то же время колоссально уменьшится в размерах.
• Хук useTransition позволяет отслеживать, происходит ли в данный момент
переход на другую страницу либо передача данных. Необходим для отображения
«оптимистичного пользовательского интерфейса» или же отрисовку индикаторов
ожидания [4].
• Многие другие.
Хотелось бы отдельно поговорить про стили в Remix. Создатели Remix
пропагандирует более традиционные подходы использования CSS. Разработчик волен
использовать любую удобную CSS-in-JS библиотеку, так как прежде всего это
приложение на React, однако фактически проблемы, которую решают данные технологии,
не существует в Remix. Нет необходимости как-либо изолировать стили, ведь во
фреймворке очень удобная система подключения стилей в зависимости от рендеринга
определенных страничных компонентов. В Remix приходится заниматься описанием
названий классов и думать о каскаде, однако практически тем же самым приходится
заниматься и в библиотеках CSS-in-JS. Для разработчика доступны опции подключения
любых библиотек компонентов, однако нет поддержки CSS Modules. В качестве CSSфреймворка для использования создатели Remix рекомендуют Tailwind и планируют в
будущем добавить его встроенную поддержку. Tailwind пропагандирует подход utility-first
и предоставляет не готовые компоненты, а низкоуровневые классы (утилиты) для
создания пользовательского дизайна. Классы имеют говорящие названия, легко понятные
обычному человеку. Remix и Tailwind очень похожи в своих взглядах на разработку
современных приложений и предоставляют минималистичные инструменты, которые
прежде всего основываются на веб-стандартах.
Remix использует файловую маршрутизацию. Корнем приложения является
app/root.tsx. Данный компонент должен предоставить точку входа для дочерних
компонентов в виде компонента Outlet. В директории routes помещаются все компоненты
дочерних маршрутов. К примеру, файл app/routes/index.tsx отрендерится на месте
компонента Outlet при запросе к /, а файл app/routes/teams.tsx – при запросе к /teams. Далее
действует следующая логика: если файл содержит внутри компонент Outlet, дочерние
компоненты Remix будет искать в директории с тем же названием, что и у файла. Remix
также поддерживает динамические параметры.
Если для компонента требуется серверная подгрузка данных, то существует особая
функция loader, которая делает асинхронные запросы к базе данных либо каким-то
образом получает необходимые данные и передает их в компонент. Хук useLoaderData
используется для получения данных из loader-функции уже внутри компонента.
Существует также особая функция action для обработки форм. Как уже было
сказано выше, в Remix придерживаются нативного подхода обработки форм, которые
могут работать без какого-либо JavaScript на стороне клиента. Внутри функции action
необходимо обработать переданный из формы объект FormData. Эта особенность
выделяет Remix среди других фреймворков, в которых для данного действия чаще всего
отдельно создаются функции-слушатели, различные хуки, переопределяется стандартное
поведение форм и используется клиентская обработка данных. В Remix же как только
форма отрендерилась на клиенте, она полностью интерактивна вне зависимости от статуса
загрузки JavaScript-кода и его наличия на странице. В функции action можно проводить
валидацию данных и при несоблюдении каких-либо правил возвращать необходимую
информацию в компонент. Эти данные можно получить уже в компоненте с помощью
хука useActionData. Стоит отметить, что у нативных форм есть ограничение: они
поддерживают только методы GET и POST. Поэтому при отправке формы с другим
методом (например, PUT) потребуется прибегать к ухищрениям. Как вариант, можно
внутри формы создать невидимый для пользователя тег input, содержащий в качестве
значения желаемый метод.
Важность интерактивности веб-приложения до полноценной загрузки JavaScript
ничуть не преувеличена, разработчики Remix в этом вопросе занимают верную позицию.
В крупных городах мы привыкли, что почти везде есть 4G. Но на самом деле даже 3G есть
далеко не везде — и его уже недостаточно для быстрой работы многим сервисам. Чаще
всего мы проверяем скорость работы наших сервисов, сидя в московских и петербургских
офисах. С проводным интернетом и находясь близко к дата-центру, мы видим
действительно хорошие цифры и думаем, что всё всегда работает быстро. Но если взять
Петропавловск-Камчатский, то картина изменится [5].
Важной особенностью Remix является также возможность обработки ошибок с
помощью специальных компонентов CatchBoundary и ErrorBoundary. Это необходимо в
случае, если при работе приложения случилась ожидаемая или внезапная ошибка. При
наличии этих компонентов ошибка в дочерних элементах не заблокирует работу всего
приложения, остальные части приложения останутся интерактивными. А с помощью
CatchBoundary и ErrorBoundary вместо компонента, на уровне которого они
располагаются, можно будет отрисовать особый интерфейс, описывающий
произошедшую ошибку. CatchBoundary необходим в ситуациях, когда action или loader
вернули объект Response[6]. Это ожидаемая ошибка, которую описал разработчик.
Получить объект данных внутри компонента можно с помощью хука useCatch. А
ErrorBoundary рендерится, когда произошла любая ошибка в компоненте дочерних
маршрутов. Причем отлавливаются ошибки, которые происходят даже в функцияхобработчиках, выполняющихся на сервере.
По аналогии со стилями в каждом компоненте можно также добавлять функцию
meta, которая возвращает мета-теги для добавления к текущей странице. Для работы этого
функционала также потребуется добавить в файл app/root.tsx в head документа компонент
Meta.
Remix даёт разработчику возможность создания ресурсных маршрутов (Resource
Routes). В качестве примера можно привести RSS, PDF, JSON API, которые можно
собирать во время обработки запроса на сервере.
Разработчики Remix всячески пропагандируют отказ от загрузочных «спиннеров»,
способствуют мгновенному получению содержательных страниц благодаря серверному
рендерингу и предзагрузке страниц. Ещё одной рекомендацией продвигается идея
«оптимистичного пользовательского интерфейса», заключающаяся в том, чтобы
отображать пользователю компонент на основе введенных им только что данных, не
дожидаясь успешного выполнения запроса на сервере. Пользовательский опыт улучшится,
не будет никакой задержки, а в случае неуспешного выполнения запроса необходимо
оповестить об этом пользователя и отрендерить компонент с актуальной информацией о
данных или ошибке.
В ходе написания статьи автором были выявлены следующие недостатки
фреймворка Remix:
• Remix на текущий момент не подходит для приложений, постоянно
взаимодействующих с сервером с помощью WebSockets. В качестве примера таких
приложений можно привести HTML5-игры. Remix не предлагает никаких убедительных
преимуществ для таких веб-приложений. Целевые приложения, для которых подходит
Remix, - приложения со встроенной маршрутизацией, а также с привязанным к этому
процессу получением данных.
• Remix не поддерживает статическую генерацию страниц, включая
инкрементальную статическую генерацию, в отличие от Next.js. Не планируется также
разрабатывать данный функционал в будущем. Remix полноценно концентрируется на
серверном рендеринге.
• Remix не предоставляет на данном этапе богатый набор встроенных
инструментов для решения различных бытовых задач, что делает Next.js (оптимизация
изображений, интернационализация, аналитика).
• Remix в качестве сборщика использует esbuild, а не Webpack, потому
микрофронтовая архитектура с помощью Module Federation также не доступна
разработчикам.
• Для передачи данных между компонентами внутри директории routes
требуется использование Context или другой технологии передачи данных. Нельзя
передавать напрямую какие-либо параметры в компонент Outlet.
• Есть также некоторые сложности с тестированием приложения, а именно с
модульным тестированием всего, что связано с серверными обработчиками компонентов.
Стоить отметить, что Remix находится только в начале своего пути. Его создатели
– большие поклонники веба, которые с заботой относятся к пользователям и
разработчикам, используя лучшие практики, стандарты и паттерны. На Remix непривычно
разрабатывать, фреймворк предоставляет достаточно низкоуровневые инструменты.
Однако идея, которую он преследует, находит отклик у многих разработчиков. Remix
заставляет всех задуматься, всегда ли есть необходимость использования библиотек
сохранения состояния приложения, различных загрузочных «спиннеров», хуков,
JavaScript в целом для абсолютно простых и базовых вещей, которые можно решить с
помощью браузерных API. Многие разработчики привыкли использовать удобные
технологии, совершенно не задумываюсь об их необходимости в конкретном проекте.
Своими приоритетами Remix ставит пользовательский опыт, быстрый и содержательный
рендеринг, минимализм в технологиях, а также полагание на основы веб-разработки, а не
их кастомизацию. Remix – технология будущего с крепкой командой и светлыми идеями,
которая определенно займет свою нишу в экосистеме веб-разработки