Целью работы является самостоятельная реконструктивная реализация миниигры по взлому терминалов, входящеи в состав компьютернои ролевои игры Fallout 3. 
Актуальность такои реализации заключается в факте отсутствия других реализации , 
достаточно точно воссоздающих все игровые правила оригинала – подавляющее 
большинство воссоздае т лишь внешнии вид и базовые правила, никак не затрагивает 
влияние характеристик игрового персонажа на сложность мини-игры. Интерес 
представляет непосредственно попытка реконструкции без доступа к исходному коду 
или документации оригинала.
По своеи концепции реализуется разновидность игры «Быки и коровы», но без 
«коров». Перед игроком появляется список слов одинаковои длины, одно из которых –
«пароль». Слова перемешаны со случаи ными символами. При выборе любого слова 
тратится попытка и выводится число букв, которые совпадают в выбранном слове и 
«пароле». Если выбрать особую комбинацию символов – либо восстановится число 
попыток, либо удалится одно из неправильных слов. Взлому подлежат только 
терминалы, чеи уровень не выше навыка «наука» персонажа игрока. Кроме того, так как 
Fallout 3 ролевая игра, на взлом терминала влияют характеристики персонажа.
Разобрав основы, приступаем к реализации. Мини-игра происходит на экране 
терминала, поэтому было решено использовать библиотеку BearLibTerminal [1], которая 
создае т терминал-подобное окно и имеет достаточно удобныи API. В качестве языка был 
выбран C#.
В теле программы происходит первичная инициализация всех параметров и 
загрузка фаи ла настроек. Также здесь находится метод меню. Меню не является частью 
оригинальнои игры, и в даннои ее реализации служит лишь удобным и быстрым 
графическим редактором фаи ла настроек. Затем начинается игровои цикл.
В игровом цикле происходит отображение текущего состояния игры и обработка 
управления. Обработка управления заключается в вызове соответствующих функции 
(перемещение курсора, активация символа или слова под курсором, вызов меню) в 
зависимости от деи ствии пользователя.
Все доступные для активации слова и символы (№ 3 на рис. 1) – элементы списка 
строк. Таким образом, курсор – это индекс строки (токена), которая будет выделена на 
экране, а также отправлена на проверку при активации.
Выделенная строка выводится в «поле ввода» (№ 5 на рис. 1). Если ее 
активировать (вызвать метод проверки токена под курсором), то она попаде т в историю 
ввода (лог) вместе с результатом проверки (№ 4 на рис. 1), которая является списком 
строк. При этом, как правило, потратится 1 попытка, либо восстановятся все попытки, 
что отражено в индикаторе оставшихся попыток (№ 1 на рис. 1).
Также на поле отображаются колонки с шестнадцатеричными «адресами» (№2 на 
рис. 1). В оригинале они всегда начинаются на F и оканчиваются на 0, C, 8, 4, т.е. кратны 
12. При создании игры генерируется такое случаи ное стартовое число, чтобы адреса в 
шестнадцатеричном виде могли начинаться от F000, и заканчиваться FFFC (поскольку 
все адреса четыре хзначные). После чего в цикле с шагом 12 (ширина колонки слов) и 
началом на стартовом числе в список строк в каждом шаге добавляется итератор, 
приведе нныи к шестнадцатеричному виду, а при составлении кадра полученныи список 
строк выводится на экран.
Класс HackGame отвечает за генерацию и хранение текущеи сессии, обработку ее 
игровои логики и отображение актуальнои информации.
Основнои информациеи о сессии являются игровое поле в виде списка строк, 
правильныи пароль и заглушки, список индексов активированных скобочных 
комбинации , список строк лога, число оставшихся попыток.
Таким образом, в HackGame производятся следующие деи ствия:
1. Инициализация, при которои устанавливаются основные настрои ки.
2. Вычисление игровых переменных, зависящих от параметров игрока:
• длина пароля, вычислена экспериментально: 
PasswordLength = 4 + 2 * TerminalLevel / 25 + Random(0,2);
• количество слов, формула взята с вики по редактору GECK для Fallout 3 [2]: 
если ScienceLevel и TerminalLevel оба равны 100, то WordsCount равен 13. Если 
TerminalLevel равен 100, то WordsMult = 0,5, иначе расче т ведется по формуле WordsMult = 
(100 - ScienceLevel) / (100 - TerminalLevel), в обоих случаях 
WordsCount = 5 + Round(15 * WordsMult);
• количество дополнительных попыток, которое достоверно установить не 
удалось по причине отсутствия документации или исходного кода в открытом доступе. 
Экспериментально выяснилось, что можно получить от 0 до 3 дополнительных 
попыток. На их число влияет «наука» (шанс убывает с ростом «науки» от 0 примерно до 
44 пунктов из 100 возможных) и «удача», приче м не вполне очевидным образом: при 
«науке» 25 и «удаче» 1 шанс на дополнительные попытки 40%, но «удаче» 2, 5, 7 и 10 
только 10% (на основании 120 экспериментов для каждого уровня «удачи», которая 
может принимать значение от 1 до 10); возможно, оригинальная формула имеет ошибку: 
такое уже случалось с другими играми этои компании-разработчика. Исходя из этого, 
можно предложить любои алгоритм, удовлетворяющии таким условиям или даже 
изменяющии потенциально ошибочное использование «удачи», по краи неи мере до тех 
пор, пока тем или иным образом не будет выяснен оригинальныи алгоритм. Наш 
вариант, исправляющии возможную ошибку:
while (rnd.Next(45) < 45 - ScienceLevel && rnd.Next(15) < LuckLevel)
MaxCurrentAttempts++;
MaxCurrentAttempts = MaxCurrentAttempts > 7 ? rnd.Next(4, 7) : MaxCurrentAttempts;
CurrentAttempts = MaxCurrentAttempts;
3. Загрузка из фаи ла со словами необходимого количества слов в список 
строк, фильтрация по вычисленнои длине пароля. Это источник пароля и заглушек. В 
нашеи реализации используется 3040 популярных слов англии ского языка, в оригинале 
используется свои список, отсутствующии в открытом доступе.
4. Заполнение игрового поля заглушками, паролем и случаи ными символами.
5. Загрузка строк интерфеи са на выбранном языке.
6. Изменение позиции курсора, а именно смещение от текущеи координаты 
или задание новых координат.
7. Проверка токена под курсором.
• Сравнение с паролем.
• Сравнение с заглушками.
• Проверка на скобочную комбинацию.
8. Установка флага успешного или проваленного взлома.
В случае провала терминал показывает экран блокировки (в оригинале после 
этого он становится недоступен для повторного взлома). В случае успеха выводит на 
экран текстовыи фаи л, в котором хранится «содержимое» терминала (в оригинале 
также показывается содержимое терминала, но интерактивное).
Отдельно можно отметить систему языковых строк. Весь игровои интерфеи с (27 
строк) хранится в виде Dictionary со структурои [Язык][НазваниеСтроки], что позволяет 
легко и просто добавлять новые языки, редактируя только .json фаи л со строками и .json 
фаи л с настрои ками, где указан ключ текущего языка. Строки проверяются на длину, 
чтобы автоматически подстроить под них ширину окна.
В итоге удалось сделать одну из самых точных реализации этои мини-игры, хотя 
некоторые формулы и механики оригинала достоверно восстановить не удалось. Ее 
можно использовать как обычную простенькую головоломку, для улучшения своих 
навыков по взлому терминалов из Fallout 3, а также в качестве реквизита для ролевых 
игр и квестов.
К недостаткам можно отнести ввод и вывод в одном потоке, в целом не лучшую 
архитектуру, привязку к .NET и необходимость скачивать и запускать приложение без 
сертификата.
Следующим этапом будет реализация веб-версии данного приложения, чтобы 
исключить загрузку непроверенных программ на компьютеры пользователеи и 
получить присущую вебу кросс-платформенность, тем самым сильно улучшив 
доступность приложения.