Хеширование – односторонняя функция, позволяющая формировать строку данных 
фиксированной длины независимо от размера исходного файла [1]. Хеш-функции 
используются для различных задач, например, для проверки целостности файлов или 
хранения паролей пользователей в базах данных [1]. Функция является необратимой – при 
нынешних вычислительных мощностях просчитать ее значение достаточно легко, но из 
полученного хеша узнать исходные данные практически невозможно [2]. В большинстве 
случаев использование «чистого» хеша уже неактуально, но на его базе построено множество 
различных алгоритмов, для каждого из которых существует своя более узкая задача.
Особенности хеш-функций. Для понимания преимуществ использования хеш-функций 
следует определить их особенности:
1. Хеширование позволяет преобразовать любой файл в строку фиксированной длины, 
которая будет зависеть от выбранного алгоритма. Например, для хеш-функции 
MD5 длина хеша будет составлять 128 бит (32 шестнадцатеричных символа), а для 
SHA3-512 – 512 бит (128 шестнадцатеричных символов). Независимо от 
первоначального размера файла хеш всегда будет иметь одну и ту же длину [1].
2. Из полученного хеш-значения (хеша) должно быть невозможным (практически 
невозможным) получение прообраза. 
3. Обладает лавинным эффектом: при малейшем изменении первообразного файла новый 
хеш будет изменен не на несколько байт, а полностью. Именно это свойство хешфункций и позволяет успешно интегрировать его в механизмы проверки целостности 
файлов или электронно-цифровой подписи (ЭЦП).
4. Расчет дайджеста должен легко реализовываться и не требовать больших затрат времени 
и вычислительных ресурсов (если не требуется обратного), как на программном, так и на 
аппаратном уровнях. 
Если длина у хеш-функции всегда одна, то число значений, которое оно может 
принять – конечное, а число обрабатываемых данных – бесконечное. Чем короче хешзначение, тем выше вероятность коллизии. Хеш-коллизии – явление, при котором разные 
прообразы дают одинаковый хеш. Хеш-коллизии являются проблемой, так как создаются 
ситуации, дающие возможность пройти сверку хеша данных даже без нахождения истинного 
прообраза.
Отдельно выделим требования к криптографическим хеш-функциям:
1. Сопротивление к нахождению первого прообраза. Достигается из свойства 
одностороннего преобразования хеш-функций.
2. Сопротивление к нахождению второго прообраза. Должно быть невозможным или 
практически невозможным нахождение прообраза, которое было не равно изначально 
хешируемому сообщению, но имеет такое же хеш-значение. Данное требование 
достигается при устойчивости хеш-функции к коллизиям [2]. 
3. Сопротивление к нахождению коллизий.
Многие ранее популярные хеш-функции мы уже не можем считать криптостойкими, они 
подвержены атакам удлинения сообщений или нахождению коллизий [3].
Проверка целостности файлов. «Лавинный эффект», скорость вычисления и длина 
хеша позволяют хеш-функции быть отличным способом решить проблему проверки 
целостности. Хеширование не обеспечивает безопасность передаваемого файла [1], за его 
шифрование отвечают другие механизмы. Значение хеш-функции позволяет определить факт 
изменения файла – при малейшей модификации хеш-значение будет абсолютно другим. 
Использование «чистого» хеша сейчас актуально только в локальных условиях, 
например, если вы копируете какой-либо большой файл. Для проверки корректности передачи 
будет достаточно просчитать хеши первоначального файла и его копии, после чего сверить [1]. 
Применение обычных контрольных сумм в глобальной сети неактуально: если у 
злоумышленника найдется способ изменить сам прикрепленный файл, он сможет изменить и 
указанный к нему хеш на сайте [1]. Хеш-сумма будет подтверждать корректность скачивания 
файла, но не его аутентичность.
Для проверки целостности сообщений лучше использовать MAC (Message authentication
code) или HMAC (Hashing message authentication code), а для проверки подлинности файла 
наилучшим решением останется ЭЦП. MAC и HMAC – криптографические хеш-функции с 
использованием ключа. Данные функции подразумевают наличие у клиента и сервера одного 
секретного ключа, используемого как для хеширования, так и для проверки. Использовать 
HMAC для проверки целостности сообщений безопаснее, чем обычный хеш [4]. HMAC
работает незначительно медленнее, чем обычная хеш-функция, так как само сообщение там 
также хешируется всего один раз, дальнейшие преобразования происходят уже с его хешем. 
Применение хеш-функций для хранения паролей в базах данных. Хеш не является 
гарантией безопасности данных, его прообраз также можно просчитать, но при правильном 
использовании алгоритмов хеширования в совокупности с другими средствами вычисление 
паролей пользователей будет слишком ресурсозатратным и практически невозможным, а 
соответственно и непривлекательным для злоумышленника. Строку данных, которая является 
паролем для авторизации пользователя, мы можем хранить несколькими способами: 
неизмененную строку; зашифрованную строку; хеш от строки. 
В первом случае, если злоумышленник получит доступ к нашей базе данных, все данные 
для авторизации сразу попадут к нему. 
Во втором случае мы можем использовать шифрование. Безусловно, методы 
классической криптографии для обеспечения безопасности современной системы 
рассматривать даже не стоит, тогда остается современная криптография с использованием 
ключей. Строка пароля хранится в базе данных в зашифрованном виде, во время прохождения 
авторизации пользователя пароль надо будет расшифровывать при помощи ключа, 
соответственно, он тоже должен храниться на сервере. Это является большой уязвимостью, 
так как при обнаружении ключа злоумышленником он сможет расшифровать все пароли без 
особого труда. 
Третий способ – в базе данных хранить хеши паролей, при авторизации сверять их с 
просчитанным хешем от введенных пользователем данных. Однако и в этом случае возникают 
проблемы: одной из особенностей хешей является то, что значение хеш-суммы от одной и той 
же информации будет всегда одинаковым. То есть, если брать в качестве примера сервис с 
большим количеством пользователей, то с очень высокой вероятностью найдутся 
пользователи с одинаковыми паролями, а соответственно и с одинаковыми значениями хешсумм. 
Стоит отметить, что не любые алгоритмы хеширования следует использовать для 
хранения паролей [3], например, алгоритм MD5 долго был актуален, но в данное время узнать 
первообразную функцию MD5-хеша относительно легко, особенно если это касается 
парольных фраз. В Интернете без особых проблем можно найти огромные словари для 
перебора значений пароля, собранные из наиболее популярных паролей среднестатистического пользователя. С добавлением дополнительных правил вариации в 
словаре находят большую часть первообразных строк. 
Решить данную проблему можно несколькими способами. В первом случае потребуется 
использовать актуальные хеш-функции, которые более устойчивы к коллизиям, в отличие от 
предшествующих им алгоритмов, построенных на основе структуры Меркла-Дамгора [3], а 
также использование случайной сгенерированной строки – соли, чтобы невозможно было 
сопоставить одинаковые пароли пользователей. Использование соли также позволит сделать 
атаку радужными таблицами невозможной, так как хеши у паролей будут различными и не 
совпадать с ранее просчитанными злоумышленником. Соль лучше всего использовать 
динамическую, так как при использовании одной статической соли для всех пользователей 
злоумышленник (хоть не сможет использовать уже готовую радужную таблицу) сможет 
сгенерировать новую для данного значения соли. В случае с динамической солью будет 
невозможно сгенерировать одну таблицу хешей, и подбирать пароли придется только методом 
«грубой силы», что, вероятнее всего, будет крайне нерезультативно при больших объемах, и 
просчет даже нескольких паролей будет занимать много времени. Вторым способом 
реализации является использование функций формирования ключа (KDF) [5].
Функции формирования ключа. Даже при использовании современных хеш-функций 
и соли остается перебор при помощи «грубой силы». Даже если это кажется слишком 
ресурсозатратным, стоит понимать, что вычислительные мощности становятся все выше, что 
делает данные атаки актуальными. 
Для того чтобы решить данную проблему, можно намеренно понизить скорость просчета 
хешей, сделать это можно при помощи функции формирования ключа [5]. Например, такой 
как PBKDF2, bcrypt или scrypt. В сочетании с солью вычисления прообраза станут 
практически невозможными при современной вычислительной мощности. 
Растяжение пароля – рекурсивный или итеративный алгоритм, который будет вычислять 
хеш-значение самого себя требуемое количество раз. Позволяет повысить энтропию ключа 
для повышения безопасности [5]. Однако использование циклического растяжения ключа не 
будет являться оптимальным решением. В данном случае следует использовать именно 
сложновычисляемые алгоритмы, которые используют хеш-функции, требующие 
относительно больших объемов памяти для вычисления. Данная задержка будет приемлема 
при одноразовой авторизации настоящего пользователя, но успешную атаку «грубой силой» 
сделает крайне маловероятной.
Выводы. В данной работе были приведены основные особенности хеш-функций, 
разобраны актуальные методы их применения в таких областях как механизм проверки 
целостности файлов и хранений пароля, приведены примеры неправильного использования, а 
также указаны оптимальные и современные решения вышеперечисленных задач.