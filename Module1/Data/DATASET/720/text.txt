React предлагает простой способ повторного применения кода, а
именно, компоненты. Компоненты включают в себя большое количество
функций, начиная от контента и стилей, а заканчивая бизнес-логикой. В
совершенстве в одном компоненте можно сразу иметь комбинацию html, css
и js, каждый из которых имеет одну цель – принцип единственной
ответственности. Если предположить, что разработчик создает приложение
электронной коммерции, то как и в любом приложении электронной
коммерции, пользователю показываются все доступные товары, так же
пользователь имеет возможность добавлять любой товар в корзину.
Разработчик, в свою очередь, получит все данные о товарах из API, которые
будут отображаться в каталоге в виде списка карт товаров. API – это некий
интерфейс взаимодействия между различными программами, а если
говорить непосредственно в веб структуре, то это интерфейс
взаимодействия разных веб-приложений и сайтов с базами данных, которые
работаю как приложение и отправляют, и принимают запросы на сервер.
Реализация компонента показана на рисунке 1.
Рисунок 1 – Компонент вывода товаров
Для владельцев приложения создается свой компонент, где
разработчик делать изменения товаров в приложении. В данном компоненте
188
отображаются данные о товарах из API, в виде таблицы. Этот компонент
можно отобразить так как показано на рисунке 2.
Рисунок 2 – Компонент TableItemProducts
В последующей разработке приложения могут возникнуть такие
ситуации:
 необходимо использовать полученные данные из API о товарах и
отображать их по-другому;
 получать данные о товарах из различных API (полезно на странице
корзины), но показать его так же, как и в ListItemProducts;
189
 вместо того, чтобы получать данные из сервера каждый раз, сохранить
их в localStorage и обращаться к данным непосредственно из localStorage;
 в каталоге товаров вместо кнопки «Удалить», добавить и другие
кнопки с действием.
При создании разных компонентов для каждой ситуации,
разработчику придётся дублировать много кода, что противоречит
принципу разработки ПО DRY (Don’t repeat yourself) - не повторяйся.
Извлечение и отображение данных являются двумя отдельными
проблемами. Как было сказано ранее, гораздо лучше, если один компонент
несет одну ответственность.
Если произвести рефакторинг первого компонента, то он будет
принимать данные о товарах в качестве props и отображать их в виде списка,
как и раньше. Поскольку нам не нужно состояние компонента и его методы
жизненного цикла, то можно преобразовать его в функциональный
компонент. Теперь это будет выглядеть так, как на рисунке 3.
Рисунок 3 – Компонент ListItemProducts после рефакторинга
Точно так же, как ListItemProducts, TableItemProducts будет
функциональным компонентом, который будет принимать данные товаров
в качестве props и отображать их в виде строк таблицы. Теперь необходимо
создать компонент с именем ProductItemFetch. Он, же в свою очередь, будет
извлекать данные о товарах из API. Выборка данных и обновление
состояния будут такими же, как в исходном компоненте ListItemProducts.
Если поместить компонент ListItemProducts в метод рендера, то разработчик
не сможет повторно использовать данный компонент для
TableItemProducts.Так или иначе, если этот компонент может спросить, что
визуализировать, то тогда проблема будет решена. Теперь необходимо в
одном месте отобразить компонент ListItemProducts, а в другом отобразить
компонент TableItemProducts. Тут уже необходимы render props и HOC. Это
190
не что иное, как способы для компонента спросить, что он должен
отображать.
Понимание Render Props на концептуальном уровне весьма
тривиально. Если забыть о React и его синтаксисе и посмотреть на пример,
созданный на JavaScript, то можно увидеть следующие: создана функция,
которая подсчитывает сумму двух чисел. Пусть сначала необходимо просто
записать результат в консоли (см. рис. 4).
Рисунок 4 – Функция суммы двух чисел
Однако функция нужна и в других местах кода. Вместо того, чтобы
отображать результат в консоль, необходимо, чтобы функция summa
предоставила только результат, и позволила вызывающей стороне решить,
как она хочет использовать этот результат (см. рис. 5).
Рисунок 5 – Функция после рефакторинга
Передается первая функция summa в callback функцию в качестве
своего аргумента arg, далее функция summa подсчитывает результат и
вызывает аргумент arg. Таким образом, callback функция получает
результат, и может использовать его в любом месте. Это формирует
сущность render props. Вместо данной функции, можно использовать
компонент ProductItemFetch, который будет извлекать данные о товарах.
Теперь можно передать функцию через props компоненту ProductItemFetch,
который извлекает данные из API и предоставляет эти данные компоненту,
191
который, в свою очередь, был передан в props. Переданный компонент
теперь может делать все, что захочет, с данными. В React данный код
реализуется следующим образом (см. рис. 6).
Рисунок 6 – Компонент ProductItemFetch
Как и аргумент arg, в компоненте есть render props, который будет
передан функции. Затем компонент ProductItemFetch вызывает эту функцию
с данными о товарах в качестве аргумента. Таким образом, можно
использовать компонент ProductItemFetch (см. рис. 7).
Рисунок 7 – Использование компонента ProductItemFetch
192
Как можно заметить, render props является достаточно универсальным
паттерном и большинство результатов может быть достигнуто очень
простым способом. Простой способ избежать вложения - разбить компонент
на более мелкие компоненты и хранить их в отдельных файлах, а
информацию передавать по средствам props из главного компонента.
Другим не менее популярным паттерном в React является компонент
высшего порядка (HOC) – это продвинутая техника в React для повторного
использования логики компонента. По сути, HOC не являются частью
ReactAPI. Это образец, который вытекает из композиционной природы
React. Этот паттерн определяет функцию, которая принимает компонент в
качестве аргумента, а затем возвращает тот же компонент, но с некоторыми
дополнительными функциями. Декоратор – это структурный паттерн
проектирования, который позволяет динамически добавлять объектам
новую функциональность, оборачивая их в полезные «обёртки».
Декораторы очень похожи на HOC, большинство языков
программирования, например, Python, имеют уже встроенные декораторы,
а JavaScript в свою очередь нет, но вскоре он будет их поддерживать.
Иллюстрация HOC приведена на рис. 8.
Рисунок 8 –HOC
Итак, как очевидно из рисунка 8, логика извлечения данных и
обновления состояния такая же, как и в render props. Единственное различие
заключается в том, что класс компонента находится внутри функции. Сама
функция принимает компонент в качестве своего аргумента, а в последствии
внутри метода рендеринга класса отображается сам компонент, который
был передан, но с дополнительными свойствами в качестве props (см. рис.
9).
193
Рисунок 9 – Использование HOC
Таким образом, в данной статье была рассмотрена необходимость
использования React паттернов render props и HOC, а также раскрыт
функционал каждого паттерна и возможности их использования для
создания компонентов многократного пользования.
