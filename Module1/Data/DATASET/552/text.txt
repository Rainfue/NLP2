В настоящее время широкое распространение приобретает разработка пользовательских интерфейсов при помощи веб-технологий (HTML, CSS) и языка программирования JavaScript. Область
применения данных средств уже много лет не ограничивается одними лишь веб-интерфейсами. Использование вышеуказанных технологий с такими программными средствами как React Native [1] и NativeScript [2] позволяет создавать кроссплатформенные приложения для iOS и Android (Facebook, Instagram, Skype), а фреймворк Electron [3] даёт возможность разрабатывать приложения для настольных
операционных систем (Discord, VSCode). Наличие такой популярности в использовании веб-технологий
для создания фронтенд приложений вызывает необходимость в использовании специальных инструментов, позволяющих разрабатывать удобные и отзывчивые пользовательские интерфейсы, а также
давать разработчику возможность масштабирования и дальнейшей поддержки программного продукта.
На сегодняшний день одними из наиболее популярных вышеупомянутых инструментов являются Ja-
ЛУЧШАЯ СТУДЕНЧЕСКАЯ СТАТЬЯ 2019 57
www.naukaip.ru
vaScript-библиотека React [4] и фреймворк Vue.js [5].
Первым аспектом, с которым приходится сталкиваться любому начинающему фронтенд разработчику, является структура создаваемого приложения. Рассматривая этот аспект нельзя не заметить
две принципиальных схожести во Vue.js и React:
 использование компонентного подхода [6, c. 43];
 выделение корневой библиотеки и вынос прочего функционала (маршрутизация, управление
глобальным состоянием приложения и т.д.) в дополнительные библиотеки.
Суть компонентного подхода заключается в выделении отдельных сущностей (компонентов) интерфейса с целью их дальнейшего повторного использования, компоновки с другими сущностями и реализации наследования. Компоненты являются своего рода строительными блоками, из которых создается пользовательский интерфейс.
Однако есть одно важное различие: React – это библиотека, в то время как Vue.js является полноценным фреймворком. Используя React, у разработчика появляется необходимость в поиске и подключении сторонних библиотек для реализации таких задач как выделение глобального состояния
приложения и реализация маршрутизации, а также возникают сложности при вовлечении других разработчиков из-за разницы используемых библиотек для решения аналогичных задач. В свою очередь, во
Vue.js весь основной функционал изначально встроен, что даёт явное преимущество по сравнению с
React, особенно для начинающих разработчиков. Но следует отметить один важный плюс в использовании сторонних библиотек для приложений на React: некоторые из них доступны для использования в
приложениях, не использующих React в качестве основной библиотеки (возможность использования, в
том числе, совместно с Vue.js).
Рис. 1. DOM-модель HTML-страницы
Важным при создании пользовательского интерфейса с использованием HTML, CSS и JavaScript
является понятие реактивности (отзывчивости). Каждая HTML-страница представлена DOM-моделью
(рис. 1). DOM (Document Object Model) – объектная модель, представленная в виде дерева. При изменении любого HTML-элемента, будут перерисованы все узлы DOM-дерева, что ухудшает качественные
характеристики интерфейса (ведь для перерисовки дерева, состоящего из более чем 10000 узлов, может потребоваться неприемлемо большое время).
В React и Vue.js решением этой проблемы является использование Virtual DOM (легковесной копии DOM). При таком подходе подразумевается внесение изменений в Virtual DOM, сравнение DOMдерева с его виртуальной копией, определение изменений и перерисовка лишь тех элементов, которые
58 ЛУЧШАЯ СТУДЕНЧЕСКАЯ СТАТЬЯ 2019
XIX Международный научно-исследовательский конкурс | МЦНС «НАУКА И ПРОСВЕЩЕНИЕ»
нуждаются в обновлении. Автоматическое отслеживание изменений, а также применение этих изменений вначале к Virtual DOM, а, в конечном счете, к DOM, составляет сущность реактивного подхода. Несмотря на использование одного подхода к реализации реактивности, рассматриваемые фреймворки
имеют различие в обновлении Virtual DOM: в React когда изменяется какой-либо из компонентов дерева, запускается повторная отрисовка всего поддерева данного компонента, начиная с себя. Чтобы избежать повторной отрисовки дочерних компонентов, нужно либо использовать PureComponent (специальный вид компонента, который отслеживает изменения своего состояния и входных параметров, но
имеет ограничение на вложенность отслеживаемых объектов), либо самостоятельно задавать условие,
при котором должна происходить повторная отрисовка, для каждого дочернего компонента, используя
метод shouldComponentUpdate. Во Vue зависимости компонента во время отрисовки автоматически
отслеживаются, поэтому система точно знает, какие компоненты необходимо повторно отрисовывать
при изменении состояния. Каждый компонент можно рассматривать как имеющий
shouldComponentUpdate, автоматически реализованный, без ограничений для вложенных узлов.
Наряду со структурой проекта стоит также вопрос об архитектуре отдельных компонентов приложения. Сравниваемые программные средства имеют принципиально разные подходы к реализации
компонентов. Во Vue.js компонент состоит из 3 основных частей:
 Template (шаблон) – HTML-разметка компонента;
 Script – данные и методы компонента, описанные на JavaScript;
 Style – описание стилей компонента с помощью CSS-классов.
Данная архитектура будет знакома любому разработчику, работавшему с традиционными вебтехнологиями. В React же прослеживается другая идея: абсолютно всё – это JavaScript. Здесь компонент создается либо в виде JavaScript-класса, наследуемого от класса Component, который реализован
в библиотеке React, либо в виде функции. Данные и методы компонента описываются внутри класса
или функции, а описание стилей может быть вынесено в JavaScript-объект или в отдельный CSS-файл.
Сам интерфейс описывается в render-функции с использованием XML-подобного декларативного синтаксиса – JSX [7, c. 81]. Плюсом такого подхода является допустимость непосредственного использования возможностей языка JavaScript внутри описания интерфейса. В качестве примеров можно привести использование временных переменных для выделения фрагментов интерфейса, введение различных операторов для реализации условной отрисовки или создания списков из подкомпонентов и т.д.
Однако нельзя не отметить то, что начиная работу с React, программисту придётся потратить время на
изучение JSX, не говоря о том, что многим разработчикам, работающим с HTML, шаблон из Vue.js будет более привычен и естественен. Таким образом, при проведении сравнения рассматриваемых
фреймворка и библиотеки, можно выделить явное преимущество первого. Архитектура компонента во
Vue.js будет более понятна и удобна в исполнении как для начинающих (четкое разделение представления и реализации), так и для опытных (использования классических веб-технологий) разработчиков.
Следующий аспект, который необходимо затронуть – данные компонента и их изменение. Понятие данных является одним из ключевых во Vue и React. Данные – это своего рода мост между представлением и JavaScript-сценарием, и реализация изменения данных напрямую влияет на организацию
реактивности в том или ином фреймворке. Хранение данных компонента и обращение к ним во Vue и
React очень схожи: в React существует специальный JavaScript-объект state, в котором располагаются
данные компонента (обращение к полю data1: this.state.data1), а во Vue есть зарезервированный метод
data, который возвращает аналогичный state объект (обращение к полю data1: this.data1) (табл. 1).
Отличие же заключается именно в реализации изменения данных. Vue позволяет напрямую изменять любое поле данных посредством обращения через ключевое слово this (this.data1 = 'новое значение'). В React же запись вида 'this.state.data2_1 = 'новое значение' не сработает, так на объект state
накладывается ограничение на изменение корневой библиотекой. Чтобы изменить поле в объекте
state, необходимо вызвать метод this.setState({ data1: 'новое значение' }). Проблемой такого вызова является случай, когда нужно изменить значение вложенного поля (вызов setState становится более громоздким с увеличением вложенности объекта state)
Использование данного метода вместо обычного присвоения значения полю вызвано наличием у
каждого компонента набора методов (componentDidMount, componentWillReceiveProps,
shouldComponentUpdate, componentWillUpdate, render, componentDidUpdate), каждый из которых вызывается на определенном этапе жизненного цикла компонента (создание компонента, получение им
входных параметров, его обновление и т.д.). Вызов метода this.setState помогает библиотеке четко
определить какие методы жизненного цикла у каких компонентов следует вызвать. Без данного метода
на React ложилась бы дополнительная нагрузка для отслеживания изменения данных, что сказалось
бы на отзывчивости пользовательского интерфейса. В случае Vue.js – фреймворк самостоятельно отслеживает и реализует аналогичный setState метод без явных потерь в производительности, что даёт
ему явное преимущество в сравнении с конкурентом.
Немаловажным критерием при сравнении таких программных инструментов является сложность
решения часто возникающих задач. Примерами таких задач во фронтэнд приложениях являются
условная отрисовка и создание списка элементов. React позволяет решать данные задачи средствами
языка программирования JavaScript. Так, например, задачу условной отрисовки можно решить с помощью опереторов if-else, switch-case или тернарного оператора, и в зависимости от выбранного условия
возвращать нужный блок представления (табл. 3). Реализация списка чаще всего выполняется посредством метода перебора элементов массива map, предоставляемым современным стандартом языка
JavaScript. Метод map позволяет трансформировать массив, что в совокупности со средствами JSX,
даёт разработчику возможность заключения каждого элемента массива в любой HTML-тег
Во Vue.js, в виду четкого разделения компонента на разделы представления и реализации, применение подхода React невозможно. Для решения подобного рода задач, разработчики фреймворка
ввели специальное понятие – директива. Директивы во Vue имеют в названии префикс 'v-' и схожи в
использовании с обычными атрибутами HTML-элементов. Управление условной отрисовкой осуществляется директивами v-if и v-else (v-else-if) (табл. 3). Условие отрисовки при таком подходе задается значением директивы. Для отрисовки списков существует директива v-for, задаваемое значение которой
имеет вид: 'item in list', где list – это перебираемый массив, а item – очередной элемент массива (табл.
4). Таким образом, Vue.js удалось внедрить конструкции языка JavaScript в HTML-разметку, сохранив
при этом границу между представлением и реализацией. Сравнение React и Vue по данному критерию
во многом носит субъективный характер, так как для разработчиков, работающих в основном с HTML,
подход Vue.js будет более удобен, в то время как для опытных разработчиков на языке JavaScript решение от React будет интуитивно понятнее. 
Подводя итог, следует отметить, что, несмотря на явное преимущество Vue.js во многих аспектах
над конкурентом, на сегодняшний день более популярным из двух средств является React. Во многом
это обусловлено более ранним выходом библиотеки в свет, а также тем фактом, что её разработка и
поддержка ведется компанией Facebook Inc. Как бы то ни было, темпы развития Vue очень высоки и
существует много примеров разработчиков, работавших c React, которые, познакомившись с Vue.js,
сменили стек технологий в пользу фреймворка. Немаловажным является и тот факт, что Vue гораздо
проще в освоении для начинающих разработчиков пользовательских интерфейсов.
