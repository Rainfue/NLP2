Анализируя код выше можно сделать вывод,
что он является выражением, имея следующие признаки:
• Целочисленный литерал (например, 0,
1,…)
• Переменная (например, x, y, abc и т. д.)
• Функция (например, (x) => increment (x));
То же, что и в javascript, но только с одним аргументом.
• Вызов (например, f (1)) также только с одним аргументом
• If выражение (например, if (isEven (x)) 1
else 2)
Здесь следует отметить несколько моментов.
Во-первых, все функции принимают 1 аргумент и
возвращают 1 значение. Для функций с несколькими аргументами мы используем технику под
названием «каррирование», например:
(x) => ((y) => (добавить (x)) (y))
Стрелка функции ассоциируется справа и вызывает ассоциацию слева, так что можно записать
ее более кратко как:
(x) => (y) => добавить (x) (y)
Если данная функция вызывается с 1 аргументом (x), она вернет другую функцию, которая принимает 1 аргумент (y), которая вызывает add с параметром Х и снова вызывает результат этого с параметром Y.
Во-вторых, «If» в большинстве языков является выражением, а не утверждением. Это означает,
что он «возвращает» значение при оценке, поэтому
можно написать следующее:
(условие) => if (условие) 1 else 2
При вызове с истиной (true) эта функция вернет 1, в противном случае - 2.
По сути, любая допустимая программа, которую пользователь вводит в файл, представлена как
«Дерево» из «Узлов». Дерево - это структура, в которой есть узлы, содержащие информацию, и при
необходимости могут быть дочерние узлы. Парсер
берет исходный текст и преобразует его в древовидную структуру, которой компилятор может
легко манипулировать. Это можно реализовать с
помощью кода следующим образом:Анализируя код видно, что каждый узел выражения имеет свойство «nodeType», которое указывает, какой тип выражения является этим узлом, и
некоторые значения, связанные с соответствующим типом.Оператор «|» означает, что тип
Expression может иметь одну из этих структур. Выражение с типом «Int» имеет свойство значения, содержащее число, которое оно представляет. Узел
типа «Var» содержит имя переменной.
Исходя из описанного выше можно составить
выражение и объект дерева:Имея функцию нам необходимо определить
тип ее тела - сделать рекурсивный вызов для вывода
тела функции. Также тело может относиться к параметру функции, поэтому его нужно добавить в
среду выполнения, сделав копию с одним дополнительным членом, который является параметром. Затем необходимо добавить <param_name,
new_type_variable> в среду и передать новое окружение и тело функции в функцию вывода.
Таким образом, в данной статье разработан
собственный компилятор на основе языка программирования Typescript и проанализирована работа
вывода типов. Для тестирования typechecker необходимо вызвать функцию infer для деревьев выражений, чтобы проверить, соответствуют ли они типам и передав начальный контекст.