Перекрестные запросы (Crosstab Query) применяются для обработки и 
представления данных в виде структуры, облегчающей их статистический анализ. 
Одна совокупность переменных (полей данных) откладывается в области заголовков 
столбцов итоговой таблицы, а вторая — в области заголовков строк. В остальном 
пространстве таблицы отображаются результаты статистических расчетов (сумма, 
среднее значение и т.д.), выполненных над данными одного поля.
Перекрестные запросы являются еще одной специфической разновидностью 
запросов на выборку. Предназначены они для более глубокого анализа информации, 
хранящейся в таблицах.
Перекрестный запрос можно отнести к запросам агрегирования данных. 
Принципы представления данных в перекрестном запросе аналогичны принципам 
представления данных в многомерных базах данных или гиперкубах данных. 
Результат перекрестного запроса представляет собой двумерную структуру, 
являющуюся одним из слоев гиперкуба.
Построение гиперкубов данных обычно рассматривается применительно к 
многомерным базам данных, построенным по схеме «звезда», то есть имеющим 
таблицу фактов и несколько таблиц измерений. Построение гиперкубов и хранение 
данных в гиперкубах довольно сложная задача и имеет смысл только при 
значительных объемах данных и необходимости проведения сложного 
статистического анализа (технологии OLAP). Перекрестный запрос предоставляет 
некоторые возможности для статистического анализа без применения многомерных 
баз данных и технологии OLAP.
Чаще всего перекрестные запросы и гиперкубы данных рассматриваются в 
приложении к бизнес анализу, однако область применения перекрестных запросов 
значительно шире.
Рассмотрим пример применения перекрестного запроса для вычисления 
средней оценки ученика по каждому предмету. Для построения запроса создадим и 
заполним таблицу оценок различных учеников по различным предметам в среде MS
Access (рис 1).
В предложенной таблице группа учеников имеет оценки по нескольким 
предметам. Ученики могут иметь сколько угодно оценок по любым предметам. 
Таким образом, ученики могут повторяться, предметы могут повторяться, оценки 
могут повторяться. Для простоты будем считать, что в группе нет однофамильцев.
Рис. 1. Исходная таблица
Построение перекрестного запроса проще всего выполнить с помощью 
«мастера», указав в качестве заголовков строк поле fam, а в качестве заголовков 
столбцов поле subject. В каждой ячейке будем вычислять среднее значение по полю 
mark.
Результатом построенного запроса будет следующая таблица, показанная на 
рисунке 2.
Просмотр запроса в режиме SQL покажет, что в запросе используется 
команда TRANSFORM:
TRANSFORM Avg(tab.mark) AS [Avg-mark]
SELECT tab.fam
FROM tab
GROUP BY tab.fam
PIVOT tab.subject;
К сожалению, многие SQL-серверы не поддерживают подобную команду и не 
позволяют построить перекрестный запрос. Следует отметить, что и компания 
Microsoft ввела такой запрос в MS SQL только с 2005 года.
Существует несколько способов построения запроса, реализующего 
аналогичные действия, однако они не лишены недостатков.
При использовании одной из наиболее популярных на сегодняшний день 
связок – SQL-сервера MYSQL и языка программирования PHP – возможно создание 
таблицы, являющейся результатом перекрестного запроса, используя возможности 
языка SQL и языка PHP. Это становиться возможным благодаря следующим 
свойствам языка PHP:
- поддержка динамических массивов;
- поддержка ассоциативных массивов;
- возможность использования в качестве индекса массива значения элементов 
другого массива.
Если рассмотреть представленную таблицу, очевидно, что она представляет 
собой двумерный массив, в котором индексами являются не числа (номер строки и 
столбца), а текст (название строки и название столбца). Причем индексами 
элементов этого массива являются значения полей исходной таблицы.
Таким образом, для построения такого массива необходимо выполнить 
следующие задачи:
- получить все различные значения поля, используемого для заголовков 
строк;
- получить все различные значения поля, используемого для заголовков 
столбцов;
- сформировать двумерный ассоциативный массив;
Рис. 2. Результат перекрестного запроса
- для каждого различного значения поля, используемого для заголовков строк 
вычислить среднее значение основного поля с группировкой по полю, 
используемому для заголовков столбцов (а в общем случае выполнить одну из 
функций агрегирования данных SQL) и переписать в соответствующие элементы 
результирующего массива.
Предложенный алгоритм не зависит от количества записей в таблице, а также 
от количества различных значений полей, используемых для заголовков строк и 
столбцов.
Исходный текст соответствующего скрипта может выглядеть так:
<?php
/*Установка соединения и выбор базы данных*/
$link = mysql_connect("localhost","root","");
mysql_select_db("db");
/*Выбираем фамилии (только разлчные значения) и 
записываем в массив для последующего использования в 
качестве индексов*/
$res = mysql_query("select distinct fam from tab order by 
fam");
$i=1;
while($arr = mysql_fetch_array($res, MYSQL_ASSOC)){
$famspec[$i] = $arr['fam'];
$i++;
}
$fam_count = $i-1;
/*Выбираем названия предметов (только различные значения) 
и записываем в массив для последующего использования в 
качестве индексов*/
$res = mysql_query("select distinct subject from tab 
order by subject");
$i=1;
while($arr = mysql_fetch_array($res, MYSQL_ASSOC)){
$dspec[$i] = $arr['subject'];
$i++;
}
$dat_count = $i-1;
/*Заполняем основной массив нулями чтобы избежать ошибки 
из-за несуществующего индекса*/
for($i = 1; $i <= $fam_count; $i++)
for($j = 1; $j <= $dat_count; $j++)
$resul[$famspec[$i]][$dspec[$j]] = 0;
/*Выбираем по фамилиям средний балл для каждого предмета 
и записываем в основной массив*/
for($i = 1; $i <= $fam_count; $i++){
$res = mysql_query("select fam, subject, avg(mark)
as av from tab where fam = '$famspec[$i]'
group by subject");
while($arr = mysql_fetch_array($res, MYSQL_ASSOC))
$resul[$arr['fam']][$arr['subject']] = 
$arr['av'];
}
/*Выводим массив*/
echo "<table border=1><tr><td></td>";
foreach($dspec as $x) echo "<td>$x</td>";
echo "</tr>";
for($i = 1; $i <= $fam_count; $i++){
echo "<tr><td>";
echo $famspec[$i];
echo "</td>";
for($j = 1; $j <= $dat_count; $j++){
echo "<td>";
echo $resul[$famspec[$i]][$dspec[$j]];
echo "</td>";}
echo "</tr>";}
echo "</table>";
?>