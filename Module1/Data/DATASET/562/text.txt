Управление потоком данных и обновлениями веб страницы в React
является чрезвычайно важным умением в разработке приложений. Крайне
нежелательно чтобы веб страница заставляла пользователя ждать или вовсе
зависала. Для достижения этих целей в React были добавлены хуки, которые
можно использовать при функциональном программировании компонентов.
То есть каждый компонент является функцией, которая возвращает JSX
элемент, а не классом как это было принято ранее. Хуками же являются также
функции, зачастую использующие функции обратного вызова для
обеспечения более легкого и максимально точечного управления данными.
IV Международная научно-практическая конференция
«Вызовы глобализации и развитие цифрового общества в условиях новой реальности»
127
Стоит понимать, что почти каждое обновление состояния, пропсов
элемента или обновления его родителя влечет за собой собственное
обновление компонента, то есть его перерисовку. Вследствие чего, обычные
переменные, будь то примитивы, собственные объекты или массивы, будут
также пересозданы, что повлечет за собой нежелательное потребление
ресурсов устройства пользователя. Помимо этого, часть производительности
уйдет на перестройку таблице стилей, поскольку веб страница воспринимает
компонент как совершенно новый узел DOM дерева.
Чтобы избежать обновления компонентов, когда их пропсы не были
изменены (в случаях если изменилось состояние родительского элемента),
необходимо использовать функцию React.memo. В неё обертывается весь
компонент и в таком случае возвращаемое значение функции сохраняется в
памяти для следующих обновлений, и его перерисовка не будет выполняться.
Стоит не забывать, что функция memo является довольно тяжелой и
злоупотреблять ей не имеет смысла, её необходимо использовать в случаях,
когда родительский элемент слишком часто обновляется и создает побочные
обновления дочерних компонентов, или если наш компонент содержит
тяжелую логику при своей перерисовке.
Функция memo также может не работать при взаимодействии со
ссылочными объектами. К примеру, если в компонент передаются анонимные
функции, то при каждом обновлении их ссылка будет пересоздана и в
дочерний компонент всегда будет приходить новый объект. Чтобы избежать
такого поведения, такие функции можно оборачивать в хук useCallback, в
который первым параметром передается сама анонимная функция, а вторым –
массив зависимостей. Таким образом, ссылка на функцию будет пересоздана
только в случае обновления объекта из списка зависимостей.
Необходимо также аккуратно использовать конструкции, приведенные
на листинге 1, поскольку ссылочный объект metadata не является примитивом,
однако мы используем его как логический тип. В таком случае, если metadata
изменится, то будет вызвано обновление, связанное с изменением ссылки
объекта и в компонент будет передано новое значение. Данная проблема
решается приведением объекта metadata к логическому типу путем двойной
инверсии, как представлено на листинге 2.
Листинг 1. Проблема нестрогой типизации JavaScript
<Metadata canRead={canRead && metadata} />
Листинг 2. Двойная инверсия объекта
<Metadata canRead={canRead && !!metadata} />
IV Международная научно-практическая конференция
«Вызовы глобализации и развитие цифрового общества в условиях новой реальности»
128
Если компонент содержит в себе тяжеловесную логику, то желательно
её также обернуть в хук useMemo, который работает по аналогии с memo и
useCallback – то есть рассчитывает необходимую логику один раз и сохраняет
результат в памяти. При последующих обращениях перерасчет будет
производиться только в случаях изменения объекта из списка зависимостей.
В React 18 была доработана система batching и теперь в случае
изменения нескольких состояний подряд при помощи хука useState,
обновления будут группироваться и производиться разово. Другими словами,
при попытке N раз обновить состояние в одной области видимости React будет
пытаться собрать все запросы в один, таким образом избежав N - 1 лишних
перерисовок.
Стоить отметить систему подписок для компонентов React. Для этого
может использоваться хук useEffect, параметром которому передается
функция и массив зависимостей. В таком случае функция будет отрабатывать
каждый раз, когда были внесены изменения в объект из списка зависимостей.
Передаваемая функция имеет возможность производит подписку, которая
происходит в основном теле функции, и отписку. В качестве возвращаемого
значения функции может быть передана другая функция, которая будет
выполнена при смене списка зависимостей. Важным замечанием является, что
если список зависимостей пуст, то функция будет отработана при
инициализации компонента, а его возвращаемая функция – при его
деструктуризации. Так создается функционал для удаления подписочных
объектов и освобождения выделенной памяти устройства.
