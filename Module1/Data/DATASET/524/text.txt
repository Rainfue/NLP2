Язык JavaScript был придуман Бренданом Эйхом в 1995
году. Его наняла компания Netscape в качестве разработчика
языка программирования, который должен был входить в состав
браузера Netscape. На данный момент JavaScript – самый
популярный язык для написания сценариев, исполняемых на
стороне клиента[1]. 27 мая 2009 года инженер-программист
Райан Даль создал технологию, превращающую JavaScript из
узкоспециализированного языка в язык общего назначения,
который через свой API взаимодействует с устройствами
ввода/вывода. Технология работает на движке V8, который
транслирует JavaScript в машинный код.
На данный момент существует два наиболее популярных
способа загрузки файлов на сервер. В качестве файла могут
выступать как бинарные, так и текстовые данные. Node.js
позволяет получать загруженные файлы из абсолютно любого
браузера, который совместим со стандартом RFC-1867. Первым
способом является загрузка файлов в директорию на сервере.
Алгоритм представлен на рис. 1. Это означает, что на сервере
создается каталог, в который будут помещаться выбранные
нами файлы и там же храниться. Файлы отправляются с форм.
Формы представляют собой компоненты HTML-разметки,
позволяющие как отправлять данные на сервер (POST-запрос),
так и принимать их с него (GET-запрос). Форма обязательно
должна иметь атрибут enctype="multipart/form-data", иначе
загрузить файлы на сервер будет не возможно. Не стоит
забывать и про валидацию файлов как на клиенте, так и на
сервере. Валидировать можно размер файла, выставив
допустимое значение поля MAX_FILE_SIZE на форме. Если
размер загружаемого файла превысит это значение, файл не
загрузится и пользователь получит специальное сообщение.
Также можно проверять допустимые форматы загружаемых
Научные
горизонты
№ 3 (19) | 2019 ISSN 2587-618Х
111
файлов на наличие их в заранее созданном списке. Как только
формат загружаемого файла совпадет с элементов массива
допустимых форматов, файл также загрузиться в директорию.
После того как файл успешно загрузился в директорию,
необходимо получить ссылку на этот файл и сохранить ее в
таблице БД. Имя файла всегда должно быть уникальным,
поскольку только в таком случае появляется возможность
однозначно идентифицировать его в таблице БД. Название
файла можно формировать путем конвертации даты и времени
загрузки файла в UNIX-формат, выборкой случайных чисел из
диапазона чисел, шифрованием оригинального названия
различными алгоритмами шифрования и т.д. Node.js основан на
работе модулей. Модули бывают встроенными и внешними.
Встроенные входят в состав ядра Node.js и подключаются
вызовом команд import * as "название переменной" from
"название модуля" или "название переменной" = require
("название модуля"). Чтобы работать с внешними модулями,
необходимо установить менеджер пакетов npm и устанавливать
сами модули командой npm install "название модуля".
В приведенном выше алгоритме мы подключаем все
необходимые библиотеки и создаем экземпляр приложения
express, который сообщения, поступающие на него на 3000
порту. Далее объявляем функцию, которая будет проверять
формат входных файлов на соответствие, и если соответствие не
будет найдено, выйдет сообщение: "Этот формат файла не
доступен для загрузки". Наша форма отправляет файл по адресу
"/files/upload", в приложении мы "отлавливаем" эту отправку и
сохраняем принятые файлы в директорию, а ссылки в таблице
БД.
Вторым способом является загрузка файла в таблицу БД
напрямую. Здесь мы будем использовать GridFS. GridFS -
правила хранения в базе данных MongoDB файлов большого
размера. Эта технология позволяет преодолевать стандартное
ограничение на хранение файлов, размер которых больше 16Мб
за счет использования коллекций. 
GridFS делит файлы на куски, которые сохраняются в
коллекцию fs.chunks, а метаданные в коллекцию fs.files. Процесс
разбиения файлов представлен на рис. 2. В MongoDB данные
хранятся в коллекциях в виде документов двоичного формата
BSON[2]. Коллекция является аналогом таблицы в реляционных
БД. Коллекция fs.chunks состоит из полей: chunks_id,
chunks.files.id, chunks.n, chunks.data. Коллекция fs.files состоит
из полей: files._id, files.length, files.chunkSize, files.uploadDate,
files.md5, files.filename, files.contentType, files.aliases,
files.metadata. При запросе к файлу GridFS совершает запрос в
коллекцию с частями файла, а затем возвращает файл
полностью.
Вместо того, чтобы хранить файл в одном документе,
GridFSразбивает файл на фрагменты и сохраняет каждую из них
в виде отдельного документа. По умолчанию размер каждого
фрагмента за исключением последнего 255Кб. Размер
последнего фрагмента рассчитывается произвольно. Таким же
образом, файлы, чей размер не превышает размер фрагмента,
используют только последний фрагмент, занимая при этом все
необходимое место и место для метаданных. Преимущество
GridFS заключается в том, что она полностью берет на себя
процесс распределения файлов. Алгоритм представлен на рис. 3.
В приведенном выше алгоритме мы настраиваем GridFSхранилище: формируем имя файла путем слияния его
оригинального имени с текущей датой, формируем имя
метаданных исходя из сформированного имени файла,
определяем коллекцию, где будут храниться файлы. При
загрузке файла будет вызываться функция upload, которая
отправляет файл в GridFS-хранилище. Как только хранилище
принимает файл, оно сравнивает его с уже имеющимися в нем
файлами, и если совпадение будет найдено, отменяет загрузку и
выдает соответствующее сообщение. Если совпадений не
найдено, создается поток для записи файла, который загружает
наш файл в коллекцию.
У каждого из рассмотренных мною
алгоритмов есть свои достоинства и недостатки. К достоинствам
первого алгоритма можно отнести высокую скорость ответа
сервера на запрос файла, поскольку сам файл хранится на
сервере, в таблице БД только его путь. К недостаткам можно
отнести безопасность хранения, поскольку получив путь
расположения файла на сервере, для злоумышленника не
составит труда получить все остальные файлы. Эта проблема
решается путем сегментации файлов на диске, т.е.
распределения их по отдельным каталогам. К достоинствам
второго способа можно отнести четкое деление файла на
фрагменты и их безопасное хранение в коллекциях.
Недостатком же является проблема производительности, часто
возникающая при получении больших по размеру файлов из БД.